# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ğŸš¨ CRITICAL: Development Rules (í•„ìˆ˜ ê°œë°œ ë£°)

**These rules MUST be followed when developing this codebase. Violating these rules will cause build failures, data loss, or team synchronization issues.**

### 1. Type Synchronization Chain (íƒ€ì… ë™ê¸°í™” ì²´ì¸)

**Rule:** Rust struct changes â†’ `npm run generate-types` â†’ Frontend changes

**Why:** This project uses `ts-rs` to auto-generate TypeScript types from Rust structs. The `shared/types.ts` file is completely auto-generated.

**MUST DO:**
- After modifying any Rust struct with `#[derive(TS)]`, immediately run `npm run generate-types`
- NEVER manually edit `shared/types.ts` - it will be overwritten

**MUST NOT DO:**
- âŒ Skip type generation after Rust changes
- âŒ Manually modify `shared/types.ts`

### 2. Database Migration Rules (DB ë§ˆì´ê·¸ë ˆì´ì…˜ ê·œì¹™)

**Rule:** Migrations must use `YYYYMMDDHHMMSS_description.sql` format and never be modified after being applied

**Why:** SQLx executes migrations in timestamp order. Modifying existing migrations breaks database consistency across team members.

**MUST DO:**
- Create new migrations with correct timestamp format: `sqlx migrate add description_here`
- After schema changes: 1) Create migration â†’ 2) Run `sqlx migrate run` â†’ 3) Update models in `crates/db/src/models/`

**MUST NOT DO:**
- âŒ Modify or delete existing migration files
- âŒ Use incorrect timestamp format
- âŒ Skip running migrations after creating them

### 3. Development Workflow (ê°œë°œ ì›Œí¬í”Œë¡œìš°)

**Rule:** Plan API specs first, then implement in any order. When Rust types change, sync immediately.

**Why:** Planning prevents rework. Implementation order is flexible (frontend can use mock data), but type synchronization is critical.

**MUST DO:**
- **Before coding**: Agree on API specs and data structures (Request/Response types, endpoints)
- **During coding**: Frontend can start first using mock data if needed
- **When Rust structs change**: IMMEDIATELY run `npm run generate-types` and sync frontend
- **Before completing**: Run `npm run check`

**Flexible Workflow:**
```
Option A (Backend first):
1. Design API spec together
2. Implement Rust backend
3. Run npm run generate-types
4. Implement frontend with real types
5. Run npm run check

Option B (Frontend first - prototyping):
1. Design API spec together
2. Implement frontend with mock data
3. Implement Rust backend
4. Run npm run generate-types
5. Replace mock with real API
6. Run npm run check
```

### 4. Auto-Generated Code (ìë™ ìƒì„± ì½”ë“œ)

**Rule:** Never manually edit auto-generated files

**Why:** These files are regenerated automatically and manual changes will be lost.

**Auto-generated files:**
- `shared/types.ts` - Generated by ts-rs from Rust structs
- (Any file with "Do not edit manually" comment at the top)

**MUST DO:**
- Edit the source (Rust) instead of the generated file (TypeScript)
- Regenerate after source changes

---

## Essential Commands

### Development
```bash
# Start development servers with hot reload (frontend + backend)
pnpm run dev

# Individual dev servers
npm run frontend:dev    # Frontend only (port 3000)
npm run backend:dev     # Backend only (port auto-assigned)

# Build production version
./build-npm-package.sh
```

### Testing & Validation
```bash
# Run all checks (frontend + backend)
npm run check

# Frontend specific
cd frontend && npm run lint          # Lint TypeScript/React code
cd frontend && npm run format:check  # Check formatting
cd frontend && npx tsc --noEmit     # TypeScript type checking

# Backend specific  
cargo test --workspace               # Run all Rust tests
cargo test -p <crate_name>          # Test specific crate
cargo test test_name                # Run specific test
cargo fmt --all -- --check          # Check Rust formatting
cargo clippy --all --all-targets --all-features -- -D warnings  # Linting

# Type generation (after modifying Rust types)
npm run generate-types               # Regenerate TypeScript types from Rust
npm run generate-types:check        # Verify types are up to date
```

### Database Operations
```bash
# SQLx migrations
sqlx migrate run                     # Apply migrations
sqlx database create                 # Create database

# Database is auto-copied from dev_assets_seed/ on dev server start
```

## MCP Server Configuration (MCP ì„œë²„ ì„¤ì •)

This project includes MCP (Model Context Protocol) server configurations in `.mcp.json` and `.claude/.mcp.json` files.

### Prerequisites (í•„ìˆ˜ ì‚¬í•­)

Before using the MCP servers, you need to install their dependencies:

**For Serena (Coding Agent Toolkit):**
```bash
# Install uv (Python package manager)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Add uv to your PATH (add this to your ~/.zshrc or ~/.bashrc)
export PATH="$HOME/.local/bin:$PATH"

# Verify installation
uv --version
```

**For context7 and memory servers:**
```bash
# These use npx and will auto-install when needed
# No additional setup required
```

### Available MCP Servers

The project is configured with the following MCP servers:

1. **context7**: Up-to-date library documentation and code examples
2. **memory**: Knowledge graph for maintaining context across sessions
3. **serena**: Semantic code retrieval and editing (supports 30+ languages including Rust)

### Testing MCP Server Configuration

To verify your MCP servers are configured correctly:

```bash
# Test serena (requires uv installation)
uvx --from git+https://github.com/oraios/serena serena start-mcp-server --help

# Test that npx can access context7
npx -y @upstash/context7-mcp --version 2>/dev/null || echo "context7 available"
```

### Modifying MCP Configuration

**DO NOT** hard-code absolute paths in `.mcp.json` files. Use relative paths or commands available in PATH so the configuration works across different environments.

**Good:**
```json
{
  "command": "uvx",
  "args": ["--from", "git+https://github.com/oraios/serena", "serena", "start-mcp-server"]
}
```

**Bad:**
```json
{
  "command": "/Users/yourname/.local/bin/uvx",  // âŒ Don't use absolute paths
  "args": ["serena", "start-mcp-server"]
}
```

### For Team Members

When you clone this repository:

1. Install uv if you want to use serena MCP server (see Prerequisites above)
2. The MCP configurations will work automatically with Claude Code
3. No need to modify `.mcp.json` files - they're already configured for portability

## Architecture Overview

### Tech Stack
- **Backend**: Rust with Axum web framework, Tokio async runtime, SQLx for database
- **Frontend**: React 18 + TypeScript + Vite, Tailwind CSS, shadcn/ui components  
- **Database**: SQLite with SQLx migrations
- **Type Sharing**: ts-rs generates TypeScript types from Rust structs
- **MCP Server**: Built-in Model Context Protocol server for AI agent integration

### Project Structure
```
crates/
â”œâ”€â”€ server/         # Axum HTTP server, API routes, MCP server
â”œâ”€â”€ db/            # Database models, migrations, SQLx queries
â”œâ”€â”€ executors/     # AI coding agent integrations (Claude, Gemini, etc.)
â”œâ”€â”€ services/      # Business logic, GitHub, auth, git operations
â”œâ”€â”€ local-deployment/  # Local deployment logic
â””â”€â”€ utils/         # Shared utilities

frontend/          # React application
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/  # React components (TaskCard, ProjectCard, etc.)
â”‚   â”œâ”€â”€ pages/      # Route pages
â”‚   â”œâ”€â”€ hooks/      # Custom React hooks (useEventSourceManager, etc.)
â”‚   â””â”€â”€ lib/        # API client, utilities

shared/types.ts    # Auto-generated TypeScript types from Rust
```

### Key Architectural Patterns

1. **Event Streaming**: Server-Sent Events (SSE) for real-time updates
   - Process logs stream to frontend via `/api/events/processes/:id/logs`
   - Task diffs stream via `/api/events/task-attempts/:id/diff`

2. **Git Worktree Management**: Each task execution gets isolated git worktree
   - Managed by `WorktreeManager` service
   - Automatic cleanup of orphaned worktrees

3. **Executor Pattern**: Pluggable AI agent executors
   - Each executor (Claude, Gemini, etc.) implements common interface
   - Actions: `coding_agent_initial`, `coding_agent_follow_up`, `script`

4. **MCP Integration**: Anyon acts as MCP server
   - Tools: `list_projects`, `list_tasks`, `create_task`, `update_task`, etc.
   - AI agents can manage tasks via MCP protocol

### API Patterns

- REST endpoints under `/api/*`
- Frontend dev server proxies to backend (configured in vite.config.ts)
- Authentication via GitHub OAuth (device flow)
- All database queries in `crates/db/src/models/`

### Development Workflow

1. **Backend changes first**: When modifying both frontend and backend, start with backend
2. **Type generation**: Run `npm run generate-types` after modifying Rust types
3. **Database migrations**: Create in `crates/db/migrations/`, apply with `sqlx migrate run`
4. **Component patterns**: Follow existing patterns in `frontend/src/components/`

### Testing Strategy

- **Unit tests**: Colocated with code in each crate
- **Integration tests**: In `tests/` directory of relevant crates  
- **Frontend tests**: TypeScript compilation and linting only
- **CI/CD**: GitHub Actions workflow in `.github/workflows/test.yml`

### Environment Variables

Build-time (set when building):
- `GITHUB_CLIENT_ID`: GitHub OAuth app ID (default: Slit's app)
- `POSTHOG_API_KEY`: Analytics key (optional)

Runtime:
- `BACKEND_PORT`: Backend server port (default: auto-assign)
- `FRONTEND_PORT`: Frontend dev port (default: 3000)
- `HOST`: Backend host (default: 127.0.0.1)
- `DISABLE_WORKTREE_ORPHAN_CLEANUP`: Debug flag for worktrees
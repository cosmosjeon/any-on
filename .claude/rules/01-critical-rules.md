# Critical Development Rules

**üö® THESE RULES MUST BE FOLLOWED - Violations cause build failures, data loss, or team sync issues**

---

## 1. Type Synchronization Chain

**Rule:** Rust struct changes ‚Üí `npm run generate-types` ‚Üí Frontend changes

**Why:** This project uses `ts-rs` to auto-generate TypeScript types from Rust structs.

### MUST DO
- After modifying any Rust struct with `#[derive(TS)]`, immediately run `npm run generate-types`
- NEVER manually edit `shared/types.ts` - it will be overwritten

### MUST NOT DO
- ‚ùå Skip type generation after Rust changes
- ‚ùå Manually modify `shared/types.ts`

**Example:**
```rust
// 1. Modify Rust struct
#[derive(Serialize, Deserialize, TS)]
#[ts(export)]
pub struct Task {
    pub id: String,
    pub title: String,
    pub status: TaskStatus,
}
```

```bash
# 2. Generate types
npm run generate-types
```

```typescript
// 3. Use in frontend (auto-generated in shared/types.ts)
import { Task } from 'shared/types';
```

---

## 2. Database Migration Rules

**Rule:** Migrations use `YYYYMMDDHHMMSS_description.sql` format and are IMMUTABLE once applied

**Why:** SQLx executes migrations in timestamp order. Modifying existing migrations breaks database consistency.

### MUST DO
- Create migrations: `sqlx migrate add description_here`
- After schema changes:
  1. Create migration
  2. Run `sqlx migrate run`
  3. Update models in `crates/db/src/models/`

### MUST NOT DO
- ‚ùå Modify existing migration files
- ‚ùå Delete migration files
- ‚ùå Use incorrect timestamp format
- ‚ùå Skip running migrations after creating them

**Example:**
```bash
# Create migration
sqlx migrate add add_task_priority

# Apply migration
sqlx migrate run

# Update models
# Edit crates/db/src/models/task.rs
```

---

## 3. Development Workflow

**Rule:** Plan API specs first, then implement in any order. Sync types immediately when Rust changes.

### Planning Phase
Before coding, agree on:
- API endpoints (method, path, params)
- Request/Response types (Rust structs)
- Error cases

### Implementation Options

**Option A: Backend First**
```
1. Design API spec together
2. Implement Rust backend
3. Run npm run generate-types
4. Implement frontend with real types
5. Run npm run check
```

**Option B: Frontend First (Prototyping)**
```
1. Design API spec together
2. Implement frontend with mock data
3. Implement Rust backend
4. Run npm run generate-types
5. Replace mock with real API
6. Run npm run check
```

### Type Sync Protocol
When Rust structs change:
1. Run `npm run generate-types` **immediately**
2. Fix TypeScript errors in frontend
3. Run `npm run check` to verify

---

## 4. Auto-Generated Code

**Rule:** NEVER manually edit auto-generated files

### Auto-Generated Files
- `shared/types.ts` - Generated by ts-rs from Rust structs
- Files with "Do not edit manually" comment at the top

### What To Do Instead
- Edit the source (Rust) instead
- Regenerate after source changes
- Commit both source and generated files together

**Example:**
```typescript
// shared/types.ts
// ‚ö†Ô∏è DO NOT EDIT - This file is auto-generated
// To modify types, edit the Rust structs and run: npm run generate-types

export type Task = { ... };
```

---

## 5. Pre-Commit Checklist

Before every commit:

- [ ] If Rust structs changed ‚Üí Ran `npm run generate-types`
- [ ] `npm run check` passes (TypeScript)
- [ ] No TypeScript errors in IDE
- [ ] No new `any` types without justification
- [ ] Followed architecture rules (see `.claude/rules/`)

---

## Quick Reference

**Type sync:** `npm run generate-types`
**Type check:** `npm run check`
**Create migration:** `sqlx migrate add <name>`
**Apply migrations:** `sqlx migrate run`

For detailed architecture rules, see:
- Frontend: `.claude/rules/02-frontend.md`
- Code Quality: `.claude/rules/04-code-quality.md`

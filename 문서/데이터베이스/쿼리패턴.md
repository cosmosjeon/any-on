# 쿼리 패턴

## 목차
1. [개요](#개요)
2. [기본 CRUD 패턴](#기본-crud-패턴)
3. [JOIN 패턴](#join-패턴)
4. [집계 쿼리](#집계-쿼리)
5. [시계열 쿼리](#시계열-쿼리)
6. [복잡한 비즈니스 로직 쿼리](#복잡한-비즈니스-로직-쿼리)
7. [성능 최적화 패턴](#성능-최적화-패턴)

---

## 개요

Anyon 프로젝트는 SQLx의 compile-time checked queries를 사용합니다. 모든 쿼리는 컴파일 타임에 검증되며, Rust 타입과 완벽하게 매핑됩니다.

### SQLx 쿼리 매크로 종류

```rust
// 1. query! - 익명 레코드 반환
let record = sqlx::query!("SELECT id, name FROM projects WHERE id = ?", id)
    .fetch_one(pool)
    .await?;

// 2. query_as! - 명명된 구조체 반환
let project = sqlx::query_as!(Project, "SELECT * FROM projects WHERE id = ?", id)
    .fetch_one(pool)
    .await?;

// 3. query_scalar! - 단일 값 반환
let count = sqlx::query_scalar!("SELECT COUNT(*) FROM tasks")
    .fetch_one(pool)
    .await?;
```

---

## 기본 CRUD 패턴

### CREATE

```rust
// 단일 레코드 삽입 + RETURNING
pub async fn create(
    pool: &SqlitePool,
    data: &CreateProject,
    project_id: Uuid,
) -> Result<Self, sqlx::Error> {
    sqlx::query_as!(
        Project,
        r#"INSERT INTO projects (id, name, git_repo_path, setup_script, dev_script, cleanup_script, copy_files)
           VALUES ($1, $2, $3, $4, $5, $6, $7)
           RETURNING id as "id!: Uuid",
                     name,
                     git_repo_path,
                     setup_script,
                     dev_script,
                     cleanup_script,
                     copy_files,
                     created_at as "created_at!: DateTime<Utc>",
                     updated_at as "updated_at!: DateTime<Utc>""#,
        project_id,
        data.name,
        data.git_repo_path,
        data.setup_script,
        data.dev_script,
        data.cleanup_script,
        data.copy_files
    )
    .fetch_one(pool)
    .await
}
```

**패턴**:
- `RETURNING *` 사용으로 생성된 레코드 즉시 반환
- `as "name!: Type"` 구문으로 타입 명시
- UUID는 애플리케이션에서 생성 후 전달

---

### READ

#### 단일 레코드 조회

```rust
pub async fn find_by_id(pool: &SqlitePool, id: Uuid) -> Result<Option<Self>, sqlx::Error> {
    sqlx::query_as!(
        Project,
        r#"SELECT id as "id!: Uuid",
                  name,
                  git_repo_path,
                  setup_script,
                  dev_script,
                  cleanup_script,
                  copy_files,
                  created_at as "created_at!: DateTime<Utc>",
                  updated_at as "updated_at!: DateTime<Utc>"
           FROM projects
           WHERE id = $1"#,
        id
    )
    .fetch_optional(pool)  // Option<T> 반환
    .await
}
```

**fetch 메서드**:
- `fetch_one()`: 정확히 1개 (없으면 RowNotFound 에러)
- `fetch_optional()`: 0개 또는 1개 (Option<T>)
- `fetch_all()`: 모든 결과 (Vec<T>)

#### 목록 조회 (정렬)

```rust
pub async fn find_all(pool: &SqlitePool) -> Result<Vec<Self>, sqlx::Error> {
    sqlx::query_as!(
        Project,
        r#"SELECT id as "id!: Uuid",
                  name,
                  git_repo_path,
                  setup_script,
                  dev_script,
                  cleanup_script,
                  copy_files,
                  created_at as "created_at!: DateTime<Utc>",
                  updated_at as "updated_at!: DateTime<Utc>"
           FROM projects
           ORDER BY created_at DESC"#
    )
    .fetch_all(pool)
    .await
}
```

---

### UPDATE

```rust
pub async fn update(
    pool: &SqlitePool,
    id: Uuid,
    name: String,
    git_repo_path: String,
    // ...
) -> Result<Self, sqlx::Error> {
    sqlx::query_as!(
        Project,
        r#"UPDATE projects
           SET name = $2,
               git_repo_path = $3,
               setup_script = $4,
               dev_script = $5,
               cleanup_script = $6,
               copy_files = $7,
               updated_at = datetime('now', 'subsec')
           WHERE id = $1
           RETURNING id as "id!: Uuid",
                     name,
                     git_repo_path,
                     setup_script,
                     dev_script,
                     cleanup_script,
                     copy_files,
                     created_at as "created_at!: DateTime<Utc>",
                     updated_at as "updated_at!: DateTime<Utc>""#,
        id,
        name,
        git_repo_path,
        setup_script,
        dev_script,
        cleanup_script,
        copy_files
    )
    .fetch_one(pool)
    .await
}
```

**패턴**:
- `updated_at = datetime('now', 'subsec')` 자동 갱신
- `RETURNING` 으로 업데이트된 레코드 반환

#### Partial Update

```rust
pub async fn update_status(
    pool: &SqlitePool,
    id: Uuid,
    status: TaskStatus,
) -> Result<(), sqlx::Error> {
    sqlx::query!(
        "UPDATE tasks SET status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $1",
        id,
        status
    )
    .execute(pool)
    .await?;
    Ok(())
}
```

---

### DELETE

```rust
pub async fn delete(pool: &SqlitePool, id: Uuid) -> Result<u64, sqlx::Error> {
    let result = sqlx::query!("DELETE FROM projects WHERE id = $1", id)
        .execute(pool)
        .await?;
    Ok(result.rows_affected())
}
```

**CASCADE 동작**:
- `ON DELETE CASCADE` 설정으로 자동으로 자식 레코드 삭제
- `rows_affected()`로 삭제된 행 수 반환

---

## JOIN 패턴

### INNER JOIN - 필수 관계

```rust
pub async fn load_context(
    pool: &SqlitePool,
    attempt_id: Uuid,
    task_id: Uuid,
    project_id: Uuid,
) -> Result<TaskAttemptContext, TaskAttemptError> {
    let task_attempt = sqlx::query_as!(
        TaskAttempt,
        r#"SELECT ta.id AS "id!: Uuid",
                  ta.task_id AS "task_id!: Uuid",
                  ta.container_ref,
                  ta.branch,
                  ta.target_branch,
                  ta.executor AS "executor!",
                  ta.worktree_deleted AS "worktree_deleted!: bool",
                  ta.setup_completed_at AS "setup_completed_at: DateTime<Utc>",
                  ta.created_at AS "created_at!: DateTime<Utc>",
                  ta.updated_at AS "updated_at!: DateTime<Utc>"
           FROM task_attempts ta
           JOIN tasks t ON ta.task_id = t.id
           JOIN projects p ON t.project_id = p.id
           WHERE ta.id = $1 AND t.id = $2 AND p.id = $3"#,
        attempt_id,
        task_id,
        project_id
    )
    .fetch_optional(pool)
    .await?
    .ok_or(TaskAttemptError::TaskNotFound)?;

    // ... 추가 조회
}
```

**패턴**:
- 3-way JOIN으로 관계 검증
- WHERE 절에서 각 레벨의 ID 확인
- `fetch_optional().ok_or()` 패턴으로 None을 에러로 변환

---

### LEFT JOIN - 선택적 관계

```rust
pub async fn find_expired_for_cleanup(
    pool: &SqlitePool,
) -> Result<Vec<(Uuid, String, String)>, sqlx::Error> {
    let records = sqlx::query!(
        r#"SELECT ta.id as "attempt_id!: Uuid",
                  ta.container_ref,
                  p.git_repo_path as "git_repo_path!"
           FROM task_attempts ta
           LEFT JOIN execution_processes ep
               ON ta.id = ep.task_attempt_id AND ep.completed_at IS NOT NULL
           JOIN tasks t ON ta.task_id = t.id
           JOIN projects p ON t.project_id = p.id
           WHERE ta.worktree_deleted = FALSE
             AND ta.id NOT IN (
                 SELECT DISTINCT ep2.task_attempt_id
                 FROM execution_processes ep2
                 WHERE ep2.completed_at IS NULL
             )
           GROUP BY ta.id, ta.container_ref, p.git_repo_path, ta.updated_at
           HAVING datetime('now', '-72 hours') > datetime(
               MAX(CASE
                   WHEN ep.completed_at IS NOT NULL THEN ep.completed_at
                   ELSE ta.updated_at
               END)
           )
           ORDER BY MAX(CASE
               WHEN ep.completed_at IS NOT NULL THEN ep.completed_at
               ELSE ta.updated_at
           END) ASC"#
    )
    .fetch_all(pool)
    .await?;

    Ok(records
        .into_iter()
        .filter_map(|r| r.container_ref.map(|path| (r.attempt_id, path, r.git_repo_path)))
        .collect())
}
```

**패턴**:
- LEFT JOIN으로 실행 프로세스가 없는 시도도 포함
- GROUP BY + MAX로 최근 활동 시각 계산
- HAVING으로 72시간 경과 필터링

---

### Self-Join - 계층 구조

```rust
// 부모-자식 태스크 관계 조회
pub async fn find_relationships_for_attempt(
    pool: &SqlitePool,
    task_attempt: &TaskAttempt,
) -> Result<TaskRelationships, sqlx::Error> {
    let current_task = Self::find_by_id(pool, task_attempt.task_id).await?
        .ok_or(sqlx::Error::RowNotFound)?;

    // 부모 태스크 조회 (parent_task_attempt → attempt → task)
    let parent_task = if let Some(parent_attempt_id) = current_task.parent_task_attempt {
        if let Ok(Some(parent_attempt)) = TaskAttempt::find_by_id(pool, parent_attempt_id).await {
            Self::find_by_id(pool, parent_attempt.task_id).await?
        } else {
            None
        }
    } else {
        None
    };

    // 자식 태스크 조회
    let children = Self::find_children_by_attempt_id(pool, task_attempt.id).await?;

    Ok(TaskRelationships {
        parent_task,
        current_attempt: task_attempt.clone(),
        children,
    })
}
```

---

## 집계 쿼리

### COUNT

```rust
pub async fn count(pool: &SqlitePool) -> Result<i64, sqlx::Error> {
    sqlx::query_scalar!(r#"SELECT COUNT(*) as "count!: i64" FROM projects"#)
        .fetch_one(pool)
        .await
}
```

### EXISTS

```rust
pub async fn exists(pool: &SqlitePool, id: Uuid, project_id: Uuid) -> Result<bool, sqlx::Error> {
    let result = sqlx::query!(
        "SELECT id as \"id!: Uuid\" FROM tasks WHERE id = $1 AND project_id = $2",
        id,
        project_id
    )
    .fetch_optional(pool)
    .await?;
    Ok(result.is_some())
}

// 또는
let result = sqlx::query!(
    r#"SELECT EXISTS(SELECT 1 FROM task_attempts WHERE container_ref = ?) as "exists!: bool""#,
    container_ref
)
.fetch_one(pool)
.await?;
```

### GROUP BY + HAVING

```rust
pub async fn find_most_active(pool: &SqlitePool, limit: i32) -> Result<Vec<Self>, sqlx::Error> {
    sqlx::query_as!(
        Project,
        r#"SELECT p.id as "id!: Uuid",
                  p.name,
                  p.git_repo_path,
                  p.setup_script,
                  p.dev_script,
                  p.cleanup_script,
                  p.copy_files,
                  p.created_at as "created_at!: DateTime<Utc>",
                  p.updated_at as "updated_at!: DateTime<Utc>"
           FROM projects p
           WHERE p.id IN (
               SELECT DISTINCT t.project_id
               FROM tasks t
               INNER JOIN task_attempts ta ON ta.task_id = t.id
               ORDER BY ta.updated_at DESC
           )
           LIMIT $1"#,
        limit
    )
    .fetch_all(pool)
    .await
}
```

---

## 시계열 쿼리

### 시간 범위 필터링

```rust
// 72시간 이내 활동
WHERE datetime('now', '-72 hours') < created_at

// 특정 날짜 이후
WHERE created_at > datetime('2025-01-01')

// 서브초 정밀도로 현재 시각
DEFAULT (datetime('now', 'subsec'))
```

### 최근/최초 레코드

```rust
// 최근 실행 프로세스
pub async fn find_latest_by_task_attempt_and_run_reason(
    pool: &SqlitePool,
    task_attempt_id: Uuid,
    run_reason: &ExecutionProcessRunReason,
) -> Result<Option<Self>, sqlx::Error> {
    sqlx::query_as!(
        ExecutionProcess,
        r#"SELECT id as "id!: Uuid",
                  task_attempt_id as "task_attempt_id!: Uuid",
                  run_reason as "run_reason!: ExecutionProcessRunReason",
                  executor_action as "executor_action!: sqlx::types::Json<ExecutorActionField>",
                  before_head_commit,
                  after_head_commit,
                  status as "status!: ExecutionProcessStatus",
                  exit_code,
                  dropped,
                  started_at as "started_at!: DateTime<Utc>",
                  completed_at as "completed_at?: DateTime<Utc>",
                  created_at as "created_at!: DateTime<Utc>",
                  updated_at as "updated_at!: DateTime<Utc>"
           FROM execution_processes
           WHERE task_attempt_id = ?
             AND run_reason = ?
             AND dropped = FALSE
           ORDER BY created_at DESC
           LIMIT 1"#,
        task_attempt_id,
        run_reason
    )
    .fetch_optional(pool)
    .await
}
```

---

## 복잡한 비즈니스 로직 쿼리

### Subquery - IN 절

```rust
// 실행 중인 프로세스가 있는 태스크
WHERE t.id IN (
    SELECT DISTINCT ta.task_id
    FROM task_attempts ta
    JOIN execution_processes ep ON ep.task_attempt_id = ta.id
    WHERE ep.status = 'running'
)

// 실행 중인 프로세스가 없는 시도 (NOT IN)
WHERE ta.id NOT IN (
    SELECT DISTINCT ep2.task_attempt_id
    FROM execution_processes ep2
    WHERE ep2.completed_at IS NULL
)
```

### CASE WHEN - 조건부 로직

```rust
pub async fn find_by_project_id_with_attempt_status(
    pool: &SqlitePool,
    project_id: Uuid,
) -> Result<Vec<TaskWithAttemptStatus>, sqlx::Error> {
    let records = sqlx::query!(
        r#"SELECT
             t.id AS "id!: Uuid",
             t.project_id AS "project_id!: Uuid",
             t.title,
             t.description,
             t.status AS "status!: TaskStatus",
             t.parent_task_attempt AS "parent_task_attempt: Uuid",
             t.created_at AS "created_at!: DateTime<Utc>",
             t.updated_at AS "updated_at!: DateTime<Utc>",

             CASE WHEN EXISTS (
                 SELECT 1
                 FROM task_attempts ta
                 JOIN execution_processes ep ON ep.task_attempt_id = ta.id
                 WHERE ta.task_id = t.id
                   AND ep.status = 'running'
                   AND ep.run_reason IN ('setupscript','cleanupscript','codingagent')
                 LIMIT 1
             ) THEN 1 ELSE 0 END AS "has_in_progress_attempt!: i64",

             CASE WHEN (
                 SELECT ep.status
                 FROM task_attempts ta
                 JOIN execution_processes ep ON ep.task_attempt_id = ta.id
                 WHERE ta.task_id = t.id
                   AND ep.run_reason IN ('setupscript','cleanupscript','codingagent')
                 ORDER BY ep.created_at DESC
                 LIMIT 1
             ) IN ('failed','killed') THEN 1 ELSE 0 END AS "last_attempt_failed!: i64",

             (SELECT ta.executor
              FROM task_attempts ta
              WHERE ta.task_id = t.id
              ORDER BY ta.created_at DESC
              LIMIT 1) AS "executor!: String"

           FROM tasks t
           WHERE t.project_id = $1
           ORDER BY t.created_at DESC"#,
        project_id
    )
    .fetch_all(pool)
    .await?;

    // ... 매핑 코드
}
```

**패턴**:
- `CASE WHEN EXISTS` 로 boolean 플래그 계산
- Subquery로 최신 값 조회
- `THEN 1 ELSE 0` → Rust에서 `!= 0` 으로 변환

---

### CTE (Common Table Expression)

SQLite 3.8.3+에서 지원:

```sql
WITH recent_processes AS (
    SELECT task_attempt_id,
           MAX(created_at) as latest_created_at
    FROM execution_processes
    GROUP BY task_attempt_id
)
SELECT ta.*, rp.latest_created_at
FROM task_attempts ta
JOIN recent_processes rp ON ta.id = rp.task_attempt_id
WHERE rp.latest_created_at > datetime('now', '-7 days')
```

---

### Window Functions

SQLite 3.25.0+에서 지원:

```sql
-- 각 태스크의 실행 시도 순위
SELECT
    ta.*,
    ROW_NUMBER() OVER (PARTITION BY ta.task_id ORDER BY ta.created_at DESC) as attempt_number
FROM task_attempts ta
```

---

## 성능 최적화 패턴

### 인덱스 활용 확인

```rust
// 복합 인덱스 활용: (task_id, created_at DESC)
SELECT * FROM task_attempts
WHERE task_id = ?
ORDER BY created_at DESC

// 부분 인덱스 활용: (queued, sending) WHERE queued = 1
SELECT * FROM drafts
WHERE queued = 1 AND sending = 0
```

### N+1 문제 해결

**Anti-pattern** (N+1):
```rust
// 1개 쿼리: 모든 태스크 조회
let tasks = Task::find_all(pool).await?;

// N개 쿼리: 각 태스크의 시도 조회
for task in tasks {
    let attempts = TaskAttempt::find_by_task_id(pool, task.id).await?;
}
```

**Best practice** (JOIN):
```rust
// 1개 쿼리로 모든 데이터 조회
let records = sqlx::query!(
    r#"SELECT t.*, ta.id as attempt_id, ta.branch, ...
       FROM tasks t
       LEFT JOIN task_attempts ta ON t.id = ta.task_id
       WHERE t.project_id = ?
       ORDER BY t.created_at DESC, ta.created_at DESC"#,
    project_id
)
.fetch_all(pool)
.await?;

// Rust에서 그룹화
let mut tasks_map = HashMap::new();
for record in records {
    tasks_map.entry(record.id).or_insert(vec![]).push(record);
}
```

---

### Batch Insert

```rust
// 여러 이미지 연결 (개별 쿼리)
for &image_id in image_ids {
    TaskImage::create(pool, &CreateTaskImage { task_id, image_id }).await?;
}

// 최적화: 단일 트랜잭션 + 중복 체크
pub async fn associate_many_dedup(
    pool: &SqlitePool,
    task_id: Uuid,
    image_ids: &[Uuid],
) -> Result<(), sqlx::Error> {
    for &image_id in image_ids {
        let id = Uuid::new_v4();
        sqlx::query!(
            r#"INSERT INTO task_images (id, task_id, image_id)
               SELECT $1, $2, $3
               WHERE NOT EXISTS (
                   SELECT 1 FROM task_images WHERE task_id = $2 AND image_id = $3
               )"#,
            id,
            task_id,
            image_id
        )
        .execute(pool)
        .await?;
    }
    Ok(())
}
```

---

### UPSERT (INSERT ... ON CONFLICT)

```rust
pub async fn upsert(
    pool: &SqlitePool,
    data: &CreateExecutionProcessLogs,
) -> Result<Self, sqlx::Error> {
    let now = Utc::now();

    sqlx::query_as!(
        ExecutionProcessLogs,
        r#"INSERT INTO execution_process_logs (execution_id, logs, byte_size, inserted_at)
           VALUES ($1, $2, $3, $4)
           ON CONFLICT (execution_id) DO UPDATE
           SET logs = logs || EXCLUDED.logs,
               byte_size = byte_size + EXCLUDED.byte_size,
               inserted_at = EXCLUDED.inserted_at
           RETURNING execution_id as "execution_id!: Uuid",
                     logs,
                     byte_size,
                     inserted_at as "inserted_at!: DateTime<Utc>""#,
        data.execution_id,
        data.logs,
        data.byte_size,
        now
    )
    .fetch_one(pool)
    .await
}
```

**패턴**:
- `ON CONFLICT (unique_key) DO UPDATE`
- `EXCLUDED.column`으로 새 값 참조
- `logs || EXCLUDED.logs` 문자열 concatenation

---

### Soft Delete 쿼리

```rust
// Soft delete: dropped 플래그 설정
pub async fn drop_at_and_after(
    pool: &SqlitePool,
    task_attempt_id: Uuid,
    boundary_process_id: Uuid,
) -> Result<i64, sqlx::Error> {
    let result = sqlx::query!(
        r#"UPDATE execution_processes
           SET dropped = TRUE
           WHERE task_attempt_id = $1
             AND created_at >= (SELECT created_at FROM execution_processes WHERE id = $2)
             AND dropped = FALSE"#,
        task_attempt_id,
        boundary_process_id
    )
    .execute(pool)
    .await?;
    Ok(result.rows_affected() as i64)
}

// 조회 시 dropped 필터링
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
  AND dropped = FALSE
ORDER BY created_at ASC
```

---

### 트랜잭션 패턴

```rust
// 단일 트랜잭션으로 여러 작업
let mut tx = pool.begin().await?;

// 1. 부모 레코드 생성
let task = sqlx::query_as!(
    Task,
    "INSERT INTO tasks (...) VALUES (...) RETURNING *",
    ...
)
.fetch_one(&mut *tx)
.await?;

// 2. 이미지 연결
for image_id in image_ids {
    sqlx::query!(
        "INSERT INTO task_images (id, task_id, image_id) VALUES (?, ?, ?)",
        Uuid::new_v4(),
        task.id,
        image_id
    )
    .execute(&mut *tx)
    .await?;
}

// 3. 커밋
tx.commit().await?;
```

---

## 타입 매핑 패턴

### UUID

```rust
// Rust: Uuid
// SQLite: BLOB

// 쿼리에서:
id as "id!: Uuid"  // Non-null
id as "id?: Uuid"  // Nullable
```

### DateTime

```rust
// Rust: chrono::DateTime<Utc>
// SQLite: TEXT (ISO8601)

// 쿼리에서:
created_at as "created_at!: DateTime<Utc>"

// 현재 시각:
DEFAULT (datetime('now', 'subsec'))  -- 서브초 정밀도
```

### Enum

```rust
// Rust: enum TaskStatus { Todo, InProgress, ... }
// SQLite: TEXT with CHECK constraint

// 쿼리에서:
status as "status!: TaskStatus"

// CHECK 제약:
CHECK (status IN ('todo','inprogress','done','cancelled','inreview'))
```

### JSON

```rust
// Rust: sqlx::types::Json<T>
// SQLite: TEXT

// 쿼리에서:
executor_action as "executor_action!: sqlx::types::Json<ExecutorActionField>"

// 저장:
let action_json = sqlx::types::Json(&executor_action);
sqlx::query!("INSERT INTO ... executor_action = ?", action_json)
```

### Boolean

```rust
// Rust: bool
// SQLite: INTEGER (0 or 1)

// 쿼리에서:
worktree_deleted as "worktree_deleted!: bool"

// CASE WHEN을 bool로:
CASE WHEN ... THEN 1 ELSE 0 END as "flag!: i64"
// Rust에서: flag != 0
```

---

## 디버깅 팁

### EXPLAIN QUERY PLAN

```sql
EXPLAIN QUERY PLAN
SELECT * FROM task_attempts
WHERE task_id = ?
ORDER BY created_at DESC;

-- 결과: SEARCH task_attempts USING INDEX idx_task_attempts_task_id_created_at
```

### SQLx 컴파일 에러 해결

```rust
// 에러: "mismatched types: expected `Uuid`, found `Vec<u8>`"
// 해결: 타입 주석 추가
id as "id!: Uuid"

// 에러: "column not found"
// 해결: RETURNING 절에 모든 컬럼 명시

// 에러: "incompatible types for field"
// 해결: Enum 이름 확인 (대소문자 구분)
```

---

## 참고 자료

- SQLx Documentation: https://github.com/launchbadge/sqlx
- SQLite SQL Reference: https://www.sqlite.org/lang.html
- 인덱스 전략: [인덱스전략.md](./인덱스전략.md)

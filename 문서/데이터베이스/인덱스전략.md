# 인덱스 전략

## 목차
1. [개요](#개요)
2. [인덱스 종류](#인덱스-종류)
3. [현재 적용된 인덱스](#현재-적용된-인덱스)
4. [인덱스 설계 원칙](#인덱스-설계-원칙)
5. [성능 분석](#성능-분석)
6. [인덱스 최적화 가이드](#인덱스-최적화-가이드)

---

## 개요

SQLite는 B-Tree 기반 인덱스를 사용합니다. 적절한 인덱스 설계는 쿼리 성능에 결정적인 영향을 미칩니다.

### 인덱스의 장단점

**장점**:
- SELECT 쿼리 속도 향상 (특히 WHERE, ORDER BY, JOIN)
- UNIQUE 제약으로 데이터 무결성 보장
- PRIMARY KEY 자동 인덱싱

**단점**:
- INSERT/UPDATE/DELETE 시 오버헤드 (인덱스도 갱신)
- 디스크 공간 사용 증가
- 과도한 인덱스는 오히려 성능 저하

---

## 인덱스 종류

### 1. PRIMARY KEY (자동 인덱스)

```sql
CREATE TABLE projects (
    id BLOB PRIMARY KEY,  -- 자동으로 UNIQUE 인덱스 생성
    ...
);
```

**특징**:
- ROWID alias (SQLite 내부 자동 증가 ID)
- UNIQUE 제약 포함
- NULL 불가

---

### 2. UNIQUE 인덱스

```sql
CREATE UNIQUE INDEX idx_projects_git_repo_path
ON projects(git_repo_path);

-- 또는 컬럼 정의 시
git_repo_path TEXT UNIQUE
```

**특징**:
- 중복 값 방지
- 자동으로 인덱스 생성
- NULL은 여러 개 허용 (SQLite 특성)

---

### 3. 단일 컬럼 인덱스

```sql
CREATE INDEX idx_execution_processes_status
ON execution_processes(status);
```

**사용 시나리오**:
- 단일 컬럼 WHERE 조건
- Cardinality가 높은 컬럼 (고유 값이 많음)

---

### 4. 복합 인덱스 (Composite Index)

```sql
CREATE INDEX idx_task_attempts_task_id_created_at
ON task_attempts(task_id, created_at DESC);
```

**사용 시나리오**:
```sql
-- 인덱스 활용 (최적)
SELECT * FROM task_attempts
WHERE task_id = ?
ORDER BY created_at DESC;

-- 부분 활용 (task_id만)
SELECT * FROM task_attempts
WHERE task_id = ?;

-- 인덱스 미활용 (첫 컬럼 없음)
SELECT * FROM task_attempts
WHERE created_at > ?;
```

**컬럼 순서 원칙**:
1. **등호(=) 조건 컬럼 먼저**
2. **범위(>, <) 조건 컬럼 나중**
3. **정렬(ORDER BY) 컬럼 마지막**

---

### 5. Partial Index (조건부 인덱스)

```sql
CREATE INDEX idx_merges_open_pr
ON merges(task_attempt_id, pr_status)
WHERE merge_type = 'pr' AND pr_status = 'open';
```

**장점**:
- 특정 조건의 데이터만 인덱싱 (공간 절약)
- 자주 조회되는 서브셋 최적화

**사용 시나리오**:
```sql
-- 인덱스 활용
SELECT * FROM merges
WHERE merge_type = 'pr' AND pr_status = 'open';

-- 인덱스 미활용 (조건 불일치)
SELECT * FROM merges
WHERE pr_status = 'open';  -- merge_type 조건 없음
```

---

### 6. Covering Index (커버링 인덱스)

```sql
CREATE INDEX idx_tasks_project_created_at
ON tasks(project_id, created_at DESC);

-- 이 쿼리는 테이블 접근 없이 인덱스만으로 처리 가능
SELECT project_id, created_at FROM tasks
WHERE project_id = ?
ORDER BY created_at DESC;
```

**특징**:
- 인덱스에 SELECT 컬럼이 모두 포함
- 테이블 접근 불필요 (매우 빠름)

---

## 현재 적용된 인덱스

### projects 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 프로젝트 고유 식별 |
| UNIQUE | Unique | `git_repo_path` | 저장소 중복 방지 |

**쿼리 패턴**:
```sql
-- id로 조회 (PRIMARY KEY 활용)
SELECT * FROM projects WHERE id = ?;

-- git_repo_path로 조회 (UNIQUE 인덱스 활용)
SELECT * FROM projects WHERE git_repo_path = ?;
```

---

### tasks 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 태스크 고유 식별 |
| `idx_tasks_project_created_at` | Composite | `(project_id, created_at DESC)` | 프로젝트별 최신 태스크 조회 |

**쿼리 패턴**:
```sql
-- 프로젝트별 태스크 목록 (인덱스 활용)
SELECT * FROM tasks
WHERE project_id = ?
ORDER BY created_at DESC;

-- 최신 태스크 (부분 활용 가능)
SELECT * FROM tasks
ORDER BY created_at DESC
LIMIT 10;
```

**EXPLAIN QUERY PLAN**:
```
SEARCH tasks USING INDEX idx_tasks_project_created_at (project_id=?)
```

---

### task_attempts 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 시도 고유 식별 |
| `idx_task_attempts_task_id_created_at` | Composite | `(task_id, created_at DESC)` | 태스크별 최신 시도 조회 |
| `idx_task_attempts_created_at` | Single | `(created_at DESC)` | 전역 최신 시도 목록 |

**쿼리 패턴**:
```sql
-- 태스크별 시도 목록 (복합 인덱스 활용)
SELECT * FROM task_attempts
WHERE task_id = ?
ORDER BY created_at DESC;

-- 전체 최신 시도 (단일 인덱스 활용)
SELECT * FROM task_attempts
ORDER BY created_at DESC
LIMIT 20;
```

**인덱스 선택 전략**:
- `WHERE task_id = ?` 있으면 → 복합 인덱스
- 없으면 → 단일 인덱스

---

### execution_processes 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 프로세스 고유 식별 |
| `idx_execution_processes_task_attempt_created_at` | Composite | `(task_attempt_id, created_at ASC)` | 시도별 실행 순서 조회 |
| `idx_execution_processes_status` | Single | `(status)` | 실행 중 프로세스 조회 |

**쿼리 패턴**:
```sql
-- 시도별 프로세스 목록 (복합 인덱스 활용)
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
ORDER BY created_at ASC;

-- 실행 중 프로세스 (단일 인덱스 활용)
SELECT * FROM execution_processes
WHERE status = 'running'
ORDER BY created_at ASC;
```

**최적화 히스토리**:
```sql
-- 구형 (2025-09-17 이전)
CREATE INDEX idx_execution_processes_task_attempt_id
ON execution_processes(task_attempt_id);

-- 개선 (복합 인덱스로 대체)
CREATE INDEX idx_execution_processes_task_attempt_created_at
ON execution_processes(task_attempt_id, created_at ASC);

DROP INDEX idx_execution_processes_task_attempt_id;  -- 중복 제거
```

**이유**:
- 기존 단일 인덱스는 정렬을 커버하지 못함
- 복합 인덱스가 단일 인덱스 역할도 수행

---

### executor_sessions 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 세션 고유 식별 |
| `idx_executor_sessions_task_attempt_id` | Single | `(task_attempt_id)` | 시도별 세션 조회 |
| `idx_executor_sessions_execution_process_id` | Single | `(execution_process_id)` | 프로세스별 세션 조회 |
| `idx_executor_sessions_session_id` | Single | `(session_id)` | 외부 세션 ID 조회 |

**쿼리 패턴**:
```sql
-- 시도별 세션
SELECT * FROM executor_sessions
WHERE task_attempt_id = ?;

-- 프로세스별 세션 (1:1)
SELECT * FROM executor_sessions
WHERE execution_process_id = ?;

-- 외부 세션 ID로 조회
SELECT * FROM executor_sessions
WHERE session_id = ?;
```

---

### execution_process_logs 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `execution_id` | 1:1 관계 (FK) |
| `idx_execution_process_logs_inserted_at` | Single | `(inserted_at)` | 최근 로그 조회 |

**특징**:
- `execution_id`가 외래 키이자 PRIMARY KEY (1:1 관계)
- UPSERT 패턴으로 로그 append

---

### merges 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 병합 레코드 고유 식별 |
| `idx_merges_task_attempt_id` | Single | `(task_attempt_id)` | 시도별 병합 정보 조회 |
| `idx_merges_open_pr` | Partial | `(task_attempt_id, pr_status)` WHERE merge_type='pr' AND pr_status='open' | Open PR 빠른 조회 |

**Partial 인덱스 활용**:
```sql
-- 인덱스 활용 (최적)
SELECT * FROM merges
WHERE merge_type = 'pr' AND pr_status = 'open';

-- 일반 인덱스 활용
SELECT * FROM merges
WHERE task_attempt_id = ?;
```

**성능 비교**:
- Open PR 비율: ~5% (대부분 merged/closed)
- Partial 인덱스 크기: 일반 인덱스의 ~5%
- 조회 속도: 동일

---

### drafts 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | Draft 고유 식별 |
| UNIQUE | Unique | `(task_attempt_id, draft_type)` | 시도당 타입별 1개만 허용 |
| `idx_drafts_task_attempt_id` | Single | `(task_attempt_id)` | 시도별 draft 조회 |
| `idx_drafts_draft_type` | Single | `(draft_type)` | 타입별 draft 조회 |
| `idx_drafts_queued_sending` | Partial | `(queued, sending)` WHERE queued=1 | 전송 대기 draft 조회 |

**Partial 인덱스 활용**:
```sql
-- 전송 대기 draft (Partial 인덱스 활용)
SELECT * FROM drafts
WHERE queued = 1 AND sending = 0;

-- 동시성 제어 (낙관적 락)
UPDATE drafts
SET sending = 1, version = version + 1
WHERE task_attempt_id = ?
  AND draft_type = ?
  AND queued = 1
  AND sending = 0;
```

---

### images 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 이미지 고유 식별 |
| UNIQUE | Unique | `hash` | SHA256 중복 방지 |
| `idx_images_hash` | Single | `hash` | 해시 기반 조회 |

**중복 제거 로직**:
```sql
-- 업로드 전 중복 체크
SELECT * FROM images WHERE hash = ?;

-- 없으면 삽입
INSERT INTO images (...) VALUES (...);
```

---

### task_images 테이블 (Junction)

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 연결 레코드 고유 식별 |
| UNIQUE | Unique | `(task_id, image_id)` | 중복 연결 방지 |
| `idx_task_images_task_id` | Single | `(task_id)` | 태스크별 이미지 조회 |
| `idx_task_images_image_id` | Single | `(image_id)` | 이미지별 태스크 조회 |

**M:N 조회 패턴**:
```sql
-- 태스크의 이미지 목록
SELECT i.* FROM images i
JOIN task_images ti ON i.id = ti.image_id
WHERE ti.task_id = ?;

-- 이미지를 사용하는 태스크 목록
SELECT t.* FROM tasks t
JOIN task_images ti ON t.id = ti.task_id
WHERE ti.image_id = ?;
```

---

### tags 테이블

| 인덱스명 | 타입 | 컬럼 | 목적 |
|---------|------|------|------|
| PRIMARY KEY | Unique | `id` | 태그 고유 식별 |

**쿼리 패턴**:
```sql
-- 전체 태그 목록 (테이블 스캔)
SELECT * FROM tags
ORDER BY tag_name ASC;
```

**최적화 여지**:
- `tag_name`으로 자주 조회 시 인덱스 추가 고려
- 현재 태그 수가 적어 테이블 스캔 허용

---

## 인덱스 설계 원칙

### 1. Cardinality (카디널리티)

**고려사항**:
- **높은 Cardinality**: 인덱스 효과적 (UUID, 이메일 등)
- **낮은 Cardinality**: 인덱스 비효율적 (boolean, enum)

**예시**:
```sql
-- 좋음: UUID (고유 값)
CREATE INDEX idx_projects_id ON projects(id);

-- 나쁨: Boolean (2가지 값만)
-- CREATE INDEX idx_worktree_deleted ON task_attempts(worktree_deleted);

-- 해결: Partial Index (조건부)
CREATE INDEX idx_active_worktrees
ON task_attempts(id)
WHERE worktree_deleted = FALSE;
```

---

### 2. Selectivity (선택도)

**정의**: 조건에 매치되는 행의 비율

```sql
-- 높은 선택도 (좋음): 1개 행
SELECT * FROM projects WHERE id = ?;

-- 낮은 선택도 (나쁨): 대부분 행
SELECT * FROM tasks WHERE status != 'cancelled';

-- 개선: 반대 조건 사용
SELECT * FROM tasks WHERE status = 'cancelled';
```

---

### 3. 복합 인덱스 컬럼 순서

**원칙**:
1. **등호 조건 (=)**: 가장 먼저
2. **범위 조건 (>, <, BETWEEN)**: 중간
3. **정렬 (ORDER BY)**: 마지막

**예시**:
```sql
-- 쿼리
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
  AND status = 'running'
ORDER BY created_at ASC;

-- 최적 인덱스 순서
CREATE INDEX idx_optimal
ON execution_processes(task_attempt_id, status, created_at ASC);

-- 덜 최적 (정렬 커버 안함)
CREATE INDEX idx_suboptimal
ON execution_processes(task_attempt_id, created_at ASC, status);
```

---

### 4. 인덱스 크기 vs 효과

**트레이드오프**:
- 인덱스 크기 = 테이블 크기의 10~50%
- 너무 많은 인덱스 = 쓰기 성능 저하

**가이드라인**:
- 테이블당 3~5개 인덱스 적정
- 자주 조회되는 패턴만 인덱싱
- 중복 인덱스 제거

---

### 5. 인덱스 유지보수

**주기적 점검**:
```sql
-- 사용되지 않는 인덱스 확인 (SQLite는 통계 미제공)
-- 쿼리 로그 분석 필요

-- 인덱스 재구성 (SQLite는 자동)
VACUUM;
```

---

## 성능 분석

### EXPLAIN QUERY PLAN

```sql
EXPLAIN QUERY PLAN
SELECT * FROM task_attempts
WHERE task_id = ?
ORDER BY created_at DESC;

-- 결과 해석:
-- SEARCH: 인덱스 사용 (좋음)
-- SCAN: 테이블 전체 스캔 (나쁨)
```

**예시**:
```
SEARCH task_attempts USING INDEX idx_task_attempts_task_id_created_at (task_id=?)
```

---

### 인덱스 활용도 측정

**Before (인덱스 없음)**:
```sql
EXPLAIN QUERY PLAN
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
ORDER BY created_at ASC;

-- SCAN execution_processes
-- USE TEMP B-TREE FOR ORDER BY
```

**After (복합 인덱스 추가)**:
```sql
CREATE INDEX idx_execution_processes_task_attempt_created_at
ON execution_processes(task_attempt_id, created_at ASC);

EXPLAIN QUERY PLAN
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
ORDER BY created_at ASC;

-- SEARCH execution_processes USING INDEX idx_execution_processes_task_attempt_created_at (task_attempt_id=?)
```

**개선 효과**:
- 테이블 스캔 제거
- 임시 정렬 제거
- 쿼리 시간: O(n) → O(log n)

---

### 실제 성능 벤치마크

**시나리오**: 100,000 execution_processes, task_attempt당 평균 50개

```sql
-- 인덱스 없음
SELECT * FROM execution_processes
WHERE task_attempt_id = ?
ORDER BY created_at ASC;
-- 평균: ~200ms (테이블 스캔 + 정렬)

-- 복합 인덱스 사용
-- 평균: ~5ms (인덱스 탐색)
-- 개선: 40배
```

---

## 인덱스 최적화 가이드

### 1. 중복 인덱스 제거

**Anti-pattern**:
```sql
-- 중복 인덱스
CREATE INDEX idx_a ON table(col_a);
CREATE INDEX idx_ab ON table(col_a, col_b);

-- idx_ab가 idx_a 역할도 수행하므로 idx_a 불필요
```

**개선**:
```sql
DROP INDEX idx_a;
-- idx_ab만 유지
```

---

### 2. Covering Index 활용

**Before**:
```sql
-- 테이블 접근 필요
SELECT id, created_at FROM tasks
WHERE project_id = ?;

CREATE INDEX idx_tasks_project
ON tasks(project_id);
```

**After**:
```sql
-- 인덱스만으로 처리 가능
CREATE INDEX idx_tasks_project_covering
ON tasks(project_id, id, created_at);
```

---

### 3. Partial Index 고려

**시나리오**: 전체의 5%만 자주 조회

**Before**:
```sql
CREATE INDEX idx_all_processes
ON execution_processes(status);

-- 인덱스 크기: 100%
```

**After**:
```sql
CREATE INDEX idx_running_processes
ON execution_processes(task_attempt_id)
WHERE status = 'running';

-- 인덱스 크기: ~5%
-- 조회 속도: 동일 또는 더 빠름
```

---

### 4. 인덱스 컬럼 순서 최적화

**쿼리 분석**:
```sql
-- 자주 실행되는 쿼리
SELECT * FROM tasks
WHERE project_id = ?
  AND status = 'todo'
ORDER BY created_at DESC;
```

**최적 인덱스**:
```sql
-- Option 1: 등호 조건 우선
CREATE INDEX idx_tasks_optimal
ON tasks(project_id, status, created_at DESC);

-- Option 2: Selectivity 고려
-- status Cardinality가 낮으면 생략 가능
CREATE INDEX idx_tasks_simple
ON tasks(project_id, created_at DESC);
```

---

### 5. 인덱스 힌트 (SQLite 제한)

**참고**: SQLite는 명시적 인덱스 힌트를 제한적으로 지원

```sql
-- INDEXED BY (강제 인덱스 사용)
SELECT * FROM tasks INDEXED BY idx_tasks_project_created_at
WHERE project_id = ?;

-- NOT INDEXED (인덱스 사용 금지)
SELECT * FROM tasks NOT INDEXED
WHERE project_id = ?;
```

**사용 주의**: 옵티마이저가 더 나은 선택을 할 수 있음

---

## 향후 최적화 계획

### 1. 쿼리 로그 분석

```bash
# SQLite 쿼리 로그 활성화
# 프로덕션 환경에서 슬로우 쿼리 식별
```

### 2. 인덱스 후보

**고려 중**:
```sql
-- 태그 이름 조회 (현재 테이블 스캔)
CREATE INDEX idx_tags_tag_name ON tags(tag_name);

-- 이미지 파일 경로 조회
CREATE INDEX idx_images_file_path ON images(file_path);
```

### 3. 파티셔닝 대안

SQLite는 파티셔닝 미지원. 대안:
- 별도 데이터베이스 파일로 분리 (프로젝트별)
- 아카이브 테이블 (오래된 데이터 이동)

---

## 참고 자료

- SQLite Query Planner: https://www.sqlite.org/queryplanner.html
- SQLite Index Documentation: https://www.sqlite.org/lang_createindex.html
- Use The Index, Luke: https://use-the-index-luke.com/

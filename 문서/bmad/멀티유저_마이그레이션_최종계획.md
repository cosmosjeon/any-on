# ë©€í‹° ìœ ì € ì§€ì› ë§ˆì´ê·¸ë ˆì´ì…˜ ìµœì¢… ê³„íš

**ì‘ì„±ì¼**: 2025-01-10
**ì˜ˆìƒ ê¸°ê°„**: ì•½ 2ì£¼ (12ì¼)
**ëª©í‘œ**: ë¡œì»¬ ë‹¨ì¼ ì‚¬ìš©ì â†’ ì›¹ ë©€í‹° ìœ ì € ì „í™˜

---

## ğŸ“‹ ëª©ì°¨
1. [í˜„ì¬ ë¬¸ì œì ](#1-í˜„ì¬-ë¬¸ì œì )
2. [ëª©í‘œ ìƒíƒœ](#2-ëª©í‘œ-ìƒíƒœ)
3. [ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ](#3-ë§ˆì´ê·¸ë ˆì´ì…˜-ì „ëµ)
4. [ìƒì„¸ êµ¬í˜„ ê³„íš](#4-ìƒì„¸-êµ¬í˜„-ê³„íš)
5. [ì•ˆì „ì¥ì¹˜](#5-ì•ˆì „ì¥ì¹˜)
6. [í…ŒìŠ¤íŠ¸ ê³„íš](#6-í…ŒìŠ¤íŠ¸-ê³„íš)
7. [ë°°í¬ ê³„íš](#7-ë°°í¬-ê³„íš)
8. [ëª¨ë‹ˆí„°ë§](#8-ëª¨ë‹ˆí„°ë§)

---

## 1. í˜„ì¬ ë¬¸ì œì 

### 1.1 ì½”ë“œë² ì´ìŠ¤ ë¶„ì„ ê²°ê³¼

**âœ… ì´ë¯¸ êµ¬í˜„ëœ ë¶€ë¶„**:
- `SecretStore` (AES-256-GCM ì•”í˜¸í™”)
- `AuthService` (GitHub OAuth Device Flow)
- `secrets` í…Œì´ë¸” (user_id TEXT ì»¬ëŸ¼ ì¡´ì¬)
- `/auth/github/device/*` API

**âŒ ë¬¸ì œì **:
- `user_id` ìƒì„±: ë¨¸ì‹  UUID í•´ì‹œ â†’ GitHub IDì™€ ë¬´ê´€
- DB í•„í„°ë§ ì—†ìŒ: `Project::find_all()` ë“±ì´ ëª¨ë“  ë°ì´í„° ë°˜í™˜
- projects/tasks/task_attempts í…Œì´ë¸”ì— user_id ì»¬ëŸ¼ ì—†ìŒ

### 1.2 ë³´ì•ˆ ìœ„í—˜

| ìœ„í—˜ | í˜„ì¬ ìƒíƒœ | ì˜í–¥ |
|-----|---------|------|
| **ë°ì´í„° ë…¸ì¶œ** | ëª¨ë“  ì‚¬ìš©ìê°€ íƒ€ì¸ì˜ í”„ë¡œì íŠ¸ ì¡°íšŒ ê°€ëŠ¥ | ğŸ”´ Critical |
| **ë°ì´í„° ìˆ˜ì •** | íƒ€ì¸ì˜ íƒœìŠ¤í¬ ìˆ˜ì •/ì‚­ì œ ê°€ëŠ¥ | ğŸ”´ Critical |
| **í”„ë¼ì´ë²„ì‹œ** | í”„ë¡œì íŠ¸ëª…, íƒœìŠ¤í¬ ë‚´ìš© ë…¸ì¶œ | ğŸ”´ Critical |
| **ë¬´ë‹¨ ì‹¤í–‰** | íƒ€ì¸ì˜ í”„ë¡œì íŠ¸ì—ì„œ AI ì‹¤í–‰ ê°€ëŠ¥ | ğŸ”´ Critical |

---

## 2. ëª©í‘œ ìƒíƒœ

### 2.1 ì‚¬ìš©ì ê²©ë¦¬
```
ì‚¬ìš©ì A
â””â”€â”€ Projects (Aë§Œ ë³¼ ìˆ˜ ìˆìŒ)
    â””â”€â”€ Tasks (Aë§Œ ë³¼ ìˆ˜ ìˆìŒ)

ì‚¬ìš©ì B
â””â”€â”€ Projects (Bë§Œ ë³¼ ìˆ˜ ìˆìŒ)
    â””â”€â”€ Tasks (Bë§Œ ë³¼ ìˆ˜ ìˆìŒ)

âŒ AëŠ” Bì˜ ë°ì´í„°ë¥¼ ë³¼ ìˆ˜ ì—†ìŒ
```

### 2.2 user_id ìƒì„± ë°©ì‹
```rust
// âŒ ê¸°ì¡´: ë¨¸ì‹  UUID í•´ì‹œ
format!("npm_user_{:016x}", hasher.finish())

// âœ… ìƒˆë¡œìš´: GitHub ID ê¸°ë°˜
format!("github_{}", github_user.id)  // "github_123456"
```

---

## 3. ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

### 3.1 ë‹¨ê³„ë³„ ì ‘ê·¼ (4 Phase)

```
Phase 1: DB ë§ˆì´ê·¸ë ˆì´ì…˜ (1ì¼)
  - user_id ì»¬ëŸ¼ ì¶”ê°€ (NULL í—ˆìš©)
  - ì¸ë±ìŠ¤ ì¶”ê°€
  - ë°ì´í„° ê²€ì¦

Phase 2: ì½”ë“œ ë³€ê²½ (2-3ì¼)
  - ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
  - user_id ê¸°ë°˜ í•„í„°ë§
  - API ë¼ìš°íŠ¸ ìˆ˜ì •

Phase 3: í”„ë¡ íŠ¸ì—”ë“œ ë³€ê²½ (1ì¼)
  - GitHub ë¡œê·¸ì¸ í•„ìˆ˜í™”
  - 401 ì—ëŸ¬ í•¸ë“¤ë§

Phase 4: í…ŒìŠ¤íŠ¸ + ë°°í¬ (2ì¼)
  - í†µí•© í…ŒìŠ¤íŠ¸
  - ìŠ¤í…Œì´ì§• ë°°í¬
  - í”„ë¡œë•ì…˜ ë°°í¬
```

### 3.2 ë°ì´í„° ì†Œìœ ê¶Œ ì´ì „ ì „ëµ

**âœ… ì²« ë¡œê·¸ì¸ ì‹œ ìë™ ì´ì „** (legacy_user ì‚­ì œ ë°©ì‹ ëŒ€ì‹ )
```rust
// ì²« GitHub ë¡œê·¸ì¸ ì‹œ ì‹¤í–‰
UPDATE projects SET user_id = 'github_123' WHERE user_id IS NULL;
```

---

## 4. ìƒì„¸ êµ¬í˜„ ê³„íš

### 4.1 DB ë§ˆì´ê·¸ë ˆì´ì…˜

#### Step 1: ì»¬ëŸ¼ ì¶”ê°€
```sql
-- migrations/YYYYMMDDHHMMSS_add_user_id_columns.sql

BEGIN IMMEDIATE;
PRAGMA foreign_keys = OFF;

-- 1. projects í…Œì´ë¸”
ALTER TABLE projects ADD COLUMN user_id TEXT;
CREATE INDEX idx_projects_user_id ON projects(user_id);

-- 2. tasks í…Œì´ë¸”
ALTER TABLE tasks ADD COLUMN user_id TEXT;
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_project_user ON tasks(project_id, user_id);

-- 3. task_attempts í…Œì´ë¸”
ALTER TABLE task_attempts ADD COLUMN user_id TEXT;
CREATE INDEX idx_task_attempts_user_id ON task_attempts(user_id);

-- 4. execution_processes í…Œì´ë¸”
ALTER TABLE execution_processes ADD COLUMN user_id TEXT;
CREATE INDEX idx_execution_processes_user_id ON execution_processes(user_id);

-- 5. images í…Œì´ë¸”
ALTER TABLE images ADD COLUMN user_id TEXT;
CREATE INDEX idx_images_user_id ON images(user_id);

-- 6. tags í…Œì´ë¸”
ALTER TABLE tags ADD COLUMN user_id TEXT;
CREATE INDEX idx_tags_user_id ON tags(user_id);

-- 7. drafts í…Œì´ë¸”
ALTER TABLE drafts ADD COLUMN user_id TEXT;
CREATE INDEX idx_drafts_user_id ON drafts(user_id);

PRAGMA foreign_keys = ON;
COMMIT;
```

#### Step 2: UNIQUE ì œì•½ ì¡°ê±´ ìˆ˜ì •
```sql
-- migrations/YYYYMMDDHHMMSS_update_unique_constraints.sql

BEGIN IMMEDIATE;

-- projects: git_repo_pathë¥¼ ì‚¬ìš©ìë³„ë¡œ ìœ ë‹ˆí¬í•˜ê²Œ
CREATE TABLE projects_new (
    id BLOB PRIMARY KEY,
    user_id TEXT,
    name TEXT NOT NULL,
    git_repo_path TEXT NOT NULL,
    setup_script TEXT DEFAULT '',
    dev_script TEXT DEFAULT '',
    cleanup_script TEXT DEFAULT '',
    copy_files TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now', 'subsec')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now', 'subsec')),
    UNIQUE(user_id, git_repo_path)
);

INSERT INTO projects_new
SELECT id, user_id, name, git_repo_path, setup_script, dev_script,
       cleanup_script, copy_files, created_at, updated_at
FROM projects;

DROP TABLE projects;
ALTER TABLE projects_new RENAME TO projects;
CREATE INDEX idx_projects_user_id ON projects(user_id);

COMMIT;
```

### 4.2 Rust ì½”ë“œ ë³€ê²½

#### 4.2.1 AuthenticatedUser ì •ì˜
```rust
// crates/server/src/auth/mod.rs (ì‹ ê·œ)

#[derive(Clone, Debug)]
pub struct AuthenticatedUser {
    pub user_id: String,      // "github_123456"
    pub github_id: i64,       // 123456
    pub username: String,     // "octocat"
    pub avatar_url: Option<String>,
}
```

#### 4.2.2 ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
```rust
// crates/server/src/middleware/auth.rs (ì‹ ê·œ)

pub async fn require_auth(
    State(deployment): State<DeploymentImpl>,
    mut req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // 1. SecretStoreì—ì„œ GitHub í† í° ì¡°íšŒ
    let token = deployment
        .secret_store()
        .get_secret_string(
            deployment.user_id(),
            SECRET_GITHUB_OAUTH,
        )
        .await
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .ok_or(StatusCode::UNAUTHORIZED)?;

    // 2. GitHub APIë¡œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ (ìºì‹œ í™œìš©)
    let gh = GitHubService::new(&token)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let user = match deployment.github_user_cache().get_or_fetch(&token, &gh).await {
        Ok(user) => user,
        Err(GitHubServiceError::TokenInvalid) => {
            // ë§Œë£Œëœ í† í° ì‚­ì œ
            let _ = deployment
                .secret_store()
                .delete_secret(deployment.user_id(), SECRET_GITHUB_OAUTH)
                .await;
            deployment.github_user_cache().invalidate(&token).await;
            return Err(StatusCode::UNAUTHORIZED);
        }
        Err(e) => {
            tracing::error!("GitHub API error: {}", e);
            return Err(StatusCode::BAD_GATEWAY);
        }
    };

    // 3. Requestì— ì‚¬ìš©ì ì •ë³´ ì£¼ì…
    req.extensions_mut().insert(AuthenticatedUser {
        user_id: format!("github_{}", user.id),
        github_id: user.id,
        username: user.login,
        avatar_url: user.avatar_url,
    });

    Ok(next.run(req).await)
}
```

#### 4.2.3 GitHub User ìºì‹œ
```rust
// crates/services/src/services/github_user_cache.rs (ì‹ ê·œ)

use lru::LruCache;
use std::num::NonZeroUsize;

#[derive(Clone)]
pub struct GitHubUserCache {
    cache: Arc<RwLock<LruCache<String, CachedUser>>>,
}

#[derive(Clone)]
struct CachedUser {
    user: GitHubUser,
    cached_at: DateTime<Utc>,
}

impl GitHubUserCache {
    pub fn new() -> Self {
        Self {
            cache: Arc::new(RwLock::new(
                LruCache::new(NonZeroUsize::new(1000).unwrap())
            )),
        }
    }

    pub async fn get_or_fetch(
        &self,
        token: &str,
        gh: &GitHubService,
    ) -> Result<GitHubUser, GitHubServiceError> {
        let cache_key = format!("{:x}", md5::compute(token));

        // ìºì‹œ í™•ì¸ (5ë¶„ TTL)
        {
            let mut guard = self.cache.write().await;
            if let Some(cached) = guard.get(&cache_key) {
                let age = Utc::now() - cached.cached_at;
                if age < chrono::Duration::minutes(5) {
                    return Ok(cached.user.clone());
                } else {
                    guard.pop(&cache_key);
                }
            }
        }

        // GitHub API í˜¸ì¶œ
        let user = gh.check_token().await?;

        // ìºì‹œ ì—…ë°ì´íŠ¸
        {
            let mut guard = self.cache.write().await;
            guard.put(
                cache_key,
                CachedUser {
                    user: user.clone(),
                    cached_at: Utc::now(),
                },
            );
        }

        Ok(user)
    }

    pub async fn invalidate(&self, token: &str) {
        let cache_key = format!("{:x}", md5::compute(token));
        let mut guard = self.cache.write().await;
        guard.pop(&cache_key);
    }
}
```

#### 4.2.4 ëª¨ë¸ ìˆ˜ì •
```rust
// crates/db/src/models/project.rs

impl Project {
    // âœ… ìƒˆ ë©”ì„œë“œ: user_id í•„í„°ë§
    pub async fn find_by_user(
        pool: &SqlitePool,
        user_id: &str,
    ) -> Result<Vec<Self>, sqlx::Error> {
        sqlx::query_as!(
            Project,
            r#"
            SELECT id as "id!: Uuid", name, git_repo_path, setup_script,
                   dev_script, cleanup_script, copy_files,
                   created_at as "created_at!: DateTime<Utc>",
                   updated_at as "updated_at!: DateTime<Utc>"
            FROM projects
            WHERE user_id = $1
            ORDER BY updated_at DESC
            "#,
            user_id
        )
        .fetch_all(pool)
        .await
    }

    // âœ… create ë©”ì„œë“œ ìˆ˜ì •
    pub async fn create(
        pool: &SqlitePool,
        data: &CreateProject,
        project_id: Uuid,
        user_id: &str,  // ì¶”ê°€
    ) -> Result<Self, sqlx::Error> {
        sqlx::query_as!(
            Project,
            r#"
            INSERT INTO projects (id, user_id, name, git_repo_path,
                                 setup_script, dev_script, cleanup_script, copy_files)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING id as "id!: Uuid", name, git_repo_path, setup_script,
                      dev_script, cleanup_script, copy_files,
                      created_at as "created_at!: DateTime<Utc>",
                      updated_at as "updated_at!: DateTime<Utc>"
            "#,
            project_id,
            user_id,  // ì¶”ê°€
            data.name,
            data.git_repo_path,
            data.setup_script,
            data.dev_script,
            data.cleanup_script,
            data.copy_files
        )
        .fetch_one(pool)
        .await
    }

    // âœ… find_by_id ìˆ˜ì • (ë³´ì•ˆ: user_id ê²€ì¦)
    pub async fn find_by_id_for_user(
        pool: &SqlitePool,
        id: Uuid,
        user_id: &str,
    ) -> Result<Option<Self>, sqlx::Error> {
        sqlx::query_as!(
            Project,
            r#"
            SELECT id as "id!: Uuid", name, git_repo_path, setup_script,
                   dev_script, cleanup_script, copy_files,
                   created_at as "created_at!: DateTime<Utc>",
                   updated_at as "updated_at!: DateTime<Utc>"
            FROM projects
            WHERE id = $1 AND user_id = $2
            "#,
            id,
            user_id
        )
        .fetch_optional(pool)
        .await
    }
}
```

#### 4.2.5 API ë¼ìš°íŠ¸ ìˆ˜ì •
```rust
// crates/server/src/routes/projects.rs

pub fn router(deployment: &DeploymentImpl) -> Router<DeploymentImpl> {
    Router::new()
        .route("/projects", get(get_projects))
        .route("/projects", post(create_project))
        .route("/projects/:id", get(get_project))
        .route("/projects/:id", put(update_project))
        .route("/projects/:id", delete(delete_project))
        // âœ… ëª¨ë“  ë¼ìš°íŠ¸ì— ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ ì ìš©
        .layer(from_fn_with_state(
            deployment.clone(),
            require_auth,
        ))
}

async fn get_projects(
    State(deployment): State<DeploymentImpl>,
    Extension(user): Extension<AuthenticatedUser>,  // âœ… ìë™ ì£¼ì…
) -> Result<Json<ApiResponse<Vec<Project>>>, ApiError> {
    let projects = Project::find_by_user(&deployment.db().pool, &user.user_id).await?;
    Ok(Json(ApiResponse::success(projects)))
}

async fn create_project(
    State(deployment): State<DeploymentImpl>,
    Extension(user): Extension<AuthenticatedUser>,
    Json(data): Json<CreateProject>,
) -> Result<Json<ApiResponse<Project>>, ApiError> {
    let id = Uuid::new_v4();
    let project = Project::create(
        &deployment.db().pool,
        &data,
        id,
        &user.user_id  // âœ… ì¶”ê°€
    ).await?;

    Ok(Json(ApiResponse::success(project)))
}
```

#### 4.2.6 ì†Œìœ ê¶Œ ì´ì „ ë¡œì§
```rust
// crates/server/src/routes/auth.rs

#[derive(Debug, Serialize)]
struct OrphanedDataClaim {
    projects_count: usize,
    tasks_count: usize,
    attempts_count: usize,
}

async fn claim_orphaned_data(
    pool: &SqlitePool,
    user_id: &str,
) -> Result<OrphanedDataClaim, ApiError> {
    let mut tx = pool.begin().await?;

    // 1. Projects ì†Œìœ ê¶Œ ì´ì „
    let projects_claimed = sqlx::query!(
        r#"
        UPDATE projects
        SET user_id = ?1
        WHERE user_id IS NULL
        RETURNING id as "id!: Uuid"
        "#,
        user_id
    )
    .fetch_all(&mut *tx)
    .await?;

    // 2. Tasks ì†Œìœ ê¶Œ ì´ì „
    let tasks_claimed = sqlx::query!(
        r#"
        UPDATE tasks
        SET user_id = ?1
        WHERE user_id IS NULL
          AND project_id IN (
              SELECT id FROM projects WHERE user_id = ?1
          )
        RETURNING id as "id!: Uuid"
        "#,
        user_id
    )
    .fetch_all(&mut *tx)
    .await?;

    // 3. Task Attempts ì†Œìœ ê¶Œ ì´ì „
    let attempts_claimed = sqlx::query!(
        r#"
        UPDATE task_attempts
        SET user_id = ?1
        WHERE user_id IS NULL
          AND task_id IN (
              SELECT id FROM tasks WHERE user_id = ?1
          )
        RETURNING id as "id!: Uuid"
        "#,
        user_id
    )
    .fetch_all(&mut *tx)
    .await?;

    tx.commit().await?;

    Ok(OrphanedDataClaim {
        projects_count: projects_claimed.len(),
        tasks_count: tasks_claimed.len(),
        attempts_count: attempts_claimed.len(),
    })
}

async fn device_poll(
    State(deployment): State<DeploymentImpl>,
) -> Result<ResponseJson<ApiResponse<DevicePollStatus>>, ApiError> {
    // ... GitHub ë¡œê·¸ì¸ ì„±ê³µ ...

    let user_id = format!("github_{}", github_user.id);

    // âœ… ì†Œìœ ê¶Œ ì´ì „
    let claim_result = claim_orphaned_data(&deployment.db().pool, &user_id).await?;

    if claim_result.projects_count > 0 {
        tracing::info!(
            "User {} claimed orphaned data: {} projects, {} tasks, {} attempts",
            user_id,
            claim_result.projects_count,
            claim_result.tasks_count,
            claim_result.attempts_count
        );

        deployment.track_if_analytics_allowed(
            "orphaned_data_claimed",
            serde_json::json!({
                "projects": claim_result.projects_count,
                "tasks": claim_result.tasks_count,
                "attempts": claim_result.attempts_count,
            }),
        ).await;
    }

    // ... ë‚˜ë¨¸ì§€ ë¡œì§ ...
}
```

### 4.3 í”„ë¡ íŠ¸ì—”ë“œ ë³€ê²½

#### 4.3.1 ì˜¨ë³´ë”© ìˆœì„œ ë³€ê²½
```typescript
// frontend/src/App.tsx

const checkOnboardingSteps = async () => {
  // 1. Disclaimer
  if (!config.disclaimer_acknowledged) {
    await NiceModal.show('disclaimer');
    await handleDisclaimerAccept();
  }

  // 2. GitHub ë¡œê·¸ì¸ (í•„ìˆ˜!) âœ…
  if (!config.github_login_acknowledged) {
    const result = await NiceModal.show('github-login', {
      required: true,  // Skip ë²„íŠ¼ ìˆ¨ê¹€
    });

    if (!result.success) {
      setError('GitHub login is required to use Anyon');
      return;
    }

    await handleGitHubLoginComplete();
  }

  // 3. ë‚˜ë¨¸ì§€ ì˜¨ë³´ë”©...
};
```

#### 4.3.2 401 ì—ëŸ¬ í•¸ë“¤ë§
```typescript
// frontend/src/lib/api.ts

let isReauthenticating = false;

apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      if (isReauthenticating) {
        return Promise.reject(error);
      }

      isReauthenticating = true;

      try {
        // ìë™ ë¡œê·¸ì•„ì›ƒ
        await api.post('/auth/github/logout');

        // ëª¨ë‹¬ ì¬í˜¸ì¶œ
        const result = await NiceModal.show('github-login', { required: true });

        if (result) {
          return apiClient.request(error.config);
        }
      } finally {
        isReauthenticating = false;
      }
    }

    return Promise.reject(error);
  }
);
```

---

## 5. ì•ˆì „ì¥ì¹˜

### 5.1 DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
## Phase 1: ì»¬ëŸ¼ ì¶”ê°€ (NULL í—ˆìš©)
- [ ] projects: ADD COLUMN user_id TEXT
- [ ] tasks: ADD COLUMN user_id TEXT
- [ ] task_attempts: ADD COLUMN user_id TEXT
- [ ] execution_processes: ADD COLUMN user_id TEXT
- [ ] images: ADD COLUMN user_id TEXT
- [ ] tags: ADD COLUMN user_id TEXT
- [ ] drafts: ADD COLUMN user_id TEXT

## Phase 2: ì¸ë±ìŠ¤ ì¶”ê°€
- [ ] idx_projects_user_id
- [ ] idx_tasks_user_id
- [ ] idx_tasks_project_user (ë³µí•©)

## Phase 3: ë°ì´í„° ê²€ì¦
- [ ] NULL user_id ê°œìˆ˜ í™•ì¸
- [ ] secrets í…Œì´ë¸”ê³¼ íƒ€ì… ì¼ì¹˜
- [ ] ì¸ë±ìŠ¤ ìƒì„± í™•ì¸

## Phase 4: ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬
- [ ] ì½”ë“œ ë°°í¬
- [ ] ì²« ë¡œê·¸ì¸ ëª¨ë‹ˆí„°ë§
- [ ] ì†Œìœ ê¶Œ ì´ì „ ë¡œê·¸ í™•ì¸
```

### 5.2 íŠ¸ëœì­ì…˜ ì•ˆì „ì„±

```rust
// WHERE user_id IS NULL ì¡°ê±´ìœ¼ë¡œ ë™ì‹œì„± ì•ˆì „ ë³´ì¥
UPDATE projects SET user_id = ?1 WHERE user_id IS NULL
```

### 5.3 í† í° ë§Œë£Œ ì²˜ë¦¬

```rust
// GitHub í† í° ë§Œë£Œ ì‹œ
1. SecretStoreì—ì„œ ì‚­ì œ
2. ìºì‹œ ë¬´íš¨í™”
3. 401 ë°˜í™˜ â†’ í”„ë¡ íŠ¸ì—”ë“œ ì¬ë¡œê·¸ì¸
```

---

## 6. í…ŒìŠ¤íŠ¸ ê³„íš

### 6.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```rust
#[sqlx::test]
async fn test_user_isolation(pool: SqlitePool) -> Result<()> {
    // User A í”„ë¡œì íŠ¸ ìƒì„±
    let project_a = Project::create(&pool, data, id, "github_111").await?;

    // User BëŠ” User A í”„ë¡œì íŠ¸ ì¡°íšŒ ë¶ˆê°€
    let result = Project::find_by_id_for_user(&pool, project_a.id, "github_222").await?;
    assert!(result.is_none());
}

#[tokio::test]
async fn test_cache_ttl_expiration() {
    // ìºì‹œ TTL 5ë¶„ í…ŒìŠ¤íŠ¸
}
```

### 6.2 í†µí•© í…ŒìŠ¤íŠ¸
```rust
#[sqlx::test]
async fn test_orphaned_data_claim(pool: SqlitePool) {
    // 1. orphaned í”„ë¡œì íŠ¸ ìƒì„±
    // 2. User A ë¡œê·¸ì¸ â†’ claim
    // 3. User B ë¡œê·¸ì¸ â†’ ì´ë¯¸ claimëœ ìƒíƒœ
}
```

---

## 7. ë°°í¬ ê³„íš

### 7.1 ìŠ¤í…Œì´ì§• ë°°í¬
```bash
# 1. ë°±ì—…
cp data/anyon.db data/anyon.db.backup.$(date +%Y%m%d_%H%M%S)

# 2. ë§ˆì´ê·¸ë ˆì´ì…˜
sqlx migrate run

# 3. ë¹Œë“œ + ë°°í¬
cargo build --release --features cloud
systemctl restart anyon
```

### 7.2 í”„ë¡œë•ì…˜ ë°°í¬
```bash
# ìŠ¤í…Œì´ì§• ê²€ì¦ í›„ ë™ì¼ ì ˆì°¨
```

---

## 8. ëª¨ë‹ˆí„°ë§

### 8.1 ë©”íŠ¸ë¦­
- Orphaned projects ê°œìˆ˜
- GitHub token invalid ë¹ˆë„
- 401 ì—ëŸ¬ ë°œìƒ íŒ¨í„´
- ìºì‹œ íˆíŠ¸ìœ¨

### 8.2 Health Check
```rust
GET /health
{
  "status": "ok",
  "migration_status": {
    "orphaned_projects": 0,
    "orphaned_tasks": 0,
    "total_users": 50
  }
}
```

### 8.3 ì•Œë¦¼ ì„¤ì •
- Orphaned projects > 100 â†’ Slack ê²½ê³ 
- GitHub token invalid ê¸‰ì¦ â†’ Sentry ì•Œë¦¼

---

## 9. íƒ€ì„ë¼ì¸

| Day | ì‘ì—… | ë‹´ë‹¹ | ìƒíƒœ |
|-----|------|------|------|
| 1 | DB ë§ˆì´ê·¸ë ˆì´ì…˜ | Backend | â³ |
| 2-3 | ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ + ëª¨ë¸ ìˆ˜ì • | Backend | â³ |
| 4 | API ë¼ìš°íŠ¸ ìˆ˜ì • | Backend | â³ |
| 5 | í”„ë¡ íŠ¸ì—”ë“œ ë³€ê²½ | Frontend | â³ |
| 6-7 | ë‹¨ìœ„ + í†µí•© í…ŒìŠ¤íŠ¸ | Full Stack | â³ |
| 8 | ìŠ¤í…Œì´ì§• ë°°í¬ | DevOps | â³ |
| 9 | ìŠ¤í…Œì´ì§• ê²€ì¦ | QA | â³ |
| 10 | í”„ë¡œë•ì…˜ ë°°í¬ | DevOps | â³ |

---

## 10. ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë°°í¬ ì „
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ SQL ì‘ì„± ì™„ë£Œ
- [ ] ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„ ì™„ë£Œ
- [ ] ëª¨ë“  ëª¨ë¸ì— user_id í•„í„°ë§ ì¶”ê°€
- [ ] API ë¼ìš°íŠ¸ ìˆ˜ì • ì™„ë£Œ
- [ ] í”„ë¡ íŠ¸ì—”ë“œ ë³€ê²½ ì™„ë£Œ
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ìŠ¤í…Œì´ì§• ë°°í¬ ì™„ë£Œ

### ë°°í¬ í›„
- [ ] Orphaned data ê°œìˆ˜ í™•ì¸
- [ ] GitHub token ìœ íš¨ì„± ëª¨ë‹ˆí„°ë§
- [ ] 401 ì—ëŸ¬ íŒ¨í„´ ë¶„ì„
- [ ] ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘

---

**ìµœì¢… ê²€í† ì¼**: 2025-01-10
**ìŠ¹ì¸ì**: [ì´ë¦„]

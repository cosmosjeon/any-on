# Anyon 백엔드 아키텍쳐 상세 문서

**프로젝트:** Anyon - 백엔드
**버전:** 0.0.116
**언어:** Rust (Edition 2024)
**프레임워크:** Axum 0.8.4
**데이터베이스:** SQLite + SQLx
**작성일:** 2025-01-08

---

## 목차

1. [백엔드 기술 스택 상세](#1-백엔드-기술-스택-상세)
2. [Crate 구성 및 의존성](#2-crate-구성-및-의존성)
3. [서버 아키텍쳐 (crates/server)](#3-서버-아키텍쳐-cratesserver)
4. [API 설계](#4-api-설계)
5. [데이터베이스 레이어 (crates/db)](#5-데이터베이스-레이어-cratesdb)
6. [비즈니스 로직 (crates/services)](#6-비즈니스-로직-cratesservices)
7. [AI Executor 시스템 (crates/executors)](#7-ai-executor-시스템-cratesexecutors)
8. [MCP 서버 구현](#8-mcp-서버-구현)
9. [실시간 통신](#9-실시간-통신)
10. [Git 통합](#10-git-통합)
11. [타입 시스템](#11-타입-시스템)
12. [비동기 아키텍쳐](#12-비동기-아키텍쳐)
13. [에러 처리](#13-에러-처리)
14. [설정 및 환경](#14-설정-및-환경)
15. [고급 주제](#15-고급-주제)

---

## 1. 백엔드 기술 스택 상세

### 1.1 핵심 프레임워크 & 런타임

| 기술 | 버전 | 용도 | 특징 |
|-----|------|-----|------|
| **Axum** | 0.8.4 | 비동기 웹 프레임워크 | Tower 기반, 타입 안전 라우팅 |
| **Tokio** | 1.0 | 비동기 런타임 | "full" 기능 활성화, work-stealing scheduler |
| **Tower-HTTP** | 0.5 | HTTP 미들웨어 | CORS 지원, 미들웨어 컴포지션 |

**Axum 기능:**
```toml
axum = { version = "0.8.4", features = ["macros", "multipart", "ws"] }
```
- `macros`: 라우터 매크로 지원
- `multipart`: 파일 업로드 처리
- `ws`: WebSocket 지원 (향후 사용 예정)

**Tokio 기능:**
```toml
tokio = { version = "1.0", features = ["full"] }
```
- 작업 생성 및 백그라운드 작업
- 동기화 프리미티브 (RwLock, Mutex)
- 타이머 및 시그널 처리
- 채널 기반 통신

### 1.2 데이터베이스 & ORM

| 기술 | 버전 | 용도 |
|-----|------|-----|
| **SQLx** | 0.8.6 | SQL 툴킷 |
| **SQLite** | 3.x | 임베디드 데이터베이스 |

**SQLx 기능:**
```toml
sqlx = {
  version = "0.8.6",
  features = [
    "sqlite",
    "runtime-tokio-rustls",
    "sqlite-preupdate-hook",
    "chrono",
    "uuid"
  ]
}
```

**특징:**
- **컴파일 타임 쿼리 검증**: 쿼리 오류를 빌드 시 감지
- **Connection Pooling**: SqlitePool로 효율적인 연결 관리
- **Preupdate Hooks**: 실시간 변경 감지 (이벤트 스트리밍용)
- **트랜잭션 지원**: ACID 트랜잭션 보장

### 1.3 직렬화 & 타입 시스템

| 기술 | 버전 | 용도 |
|-----|------|-----|
| **serde** | 1.0 | 직렬화/역직렬화 프레임워크 |
| **serde_json** | - | JSON 지원 (preserve_order 활성화) |
| **ts-rs** | custom fork | Rust → TypeScript 타입 생성 |
| **schemars** | 1.0.4 | JSON Schema 생성 |

**ts-rs 설정:**
```toml
ts-rs = {
  git = "https://github.com/xazukx/ts-rs.git",
  branch = "use-ts-enum",
  features = ["uuid", "chrono-impl", "serde-json-impl", "no-warnings"]
}
```

**ts-rs 사용 예:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, TS)]
#[ts(export)]
pub struct Task {
    pub id: Uuid,
    pub title: String,
    pub status: TaskStatus,
    pub created_at: DateTime<Utc>,
}
```

### 1.4 비동기 & 동시성

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **async-trait** | 0.1 | 비동기 트레이트 메서드 |
| **futures-util** | 0.3 | 비동기 유틸리티 |
| **futures** | 0.3.31 | 핵심 futures 라이브러리 |
| **tokio-util** | 0.7 | Tokio 유틸리티 |
| **tokio-stream** | 0.1.17 | Tokio용 스트림 컴비네이터 |

**async-trait 예시:**
```rust
#[async_trait]
pub trait Executor {
    async fn execute_initial_request(
        &self,
        request: CodingAgentInitialRequest,
    ) -> Result<ExecutorResult>;
}
```

### 1.5 프로세스 & 시스템 관리

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **command-group** | 5.0 | 프로세스 그룹 관리 (with-tokio) |
| **nix** | 0.29 | POSIX 시스템 콜 (signal, process) |
| **os_info** | 3.12.0 | OS 감지 |
| **os_pipe** | 1.2 | OS 레벨 파이프 |

**command-group 특징:**
- 프로세스를 프로세스 그룹으로 생성
- 그룹 시그널 처리 활성화
- 자식 프로세스 누수 방지

**nix 사용:**
```rust
use nix::sys::signal::{kill, Signal};
use nix::unistd::Pid;

// 프로세스 그룹에 시그널 전송
kill(Pid::from_raw(-pid), Signal::SIGTERM)?;
```

### 1.6 에러 처리 & 로깅

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **thiserror** | 2.0.12 | 에러 타입 파생 |
| **anyhow** | 1.0 | 유연한 에러 처리 |
| **tracing** | 0.1 | 구조화된 로깅 |
| **tracing-subscriber** | 0.3 | 트레이싱 레이어 (env-filter) |
| **sentry** | 0.41.0 | 에러 추적 & 모니터링 |
| **sentry-tracing** | 0.41.0 | Tracing과 Sentry 통합 |

**thiserror 예시:**
```rust
#[derive(Error, Debug)]
pub enum GitServiceError {
    #[error("Repository not found: {0}")]
    RepoNotFound(String),

    #[error("Git operation failed: {0}")]
    GitError(#[from] git2::Error),

    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}
```

**tracing 사용:**
```rust
#[tracing::instrument(skip(pool))]
async fn create_task(
    pool: &SqlitePool,
    data: CreateTask,
) -> Result<Task> {
    tracing::info!("Creating task: {}", data.title);
    // ...
}
```

### 1.7 Git & 버전 컨트롤

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **git2** | 0.18 | libgit2 Rust 바인딩 |
| **ignore** | 0.4 | .gitignore 파일 무시 패턴 |
| **octocrab** | 0.44 | GitHub API 클라이언트 |

**git2 주요 기능:**
```rust
use git2::{Repository, Branch, BranchType, Diff};

// 저장소 열기
let repo = Repository::open(&path)?;

// 워크트리 생성
repo.worktree(
    "task-123",
    &worktree_path,
    Some(&mut opts),
)?;

// Diff 생성
let diff = repo.diff_tree_to_workdir(Some(&tree), Some(&mut opts))?;
```

### 1.8 HTTP & 네트워크

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **reqwest** | 0.12 | HTTP 클라이언트 (JSON 지원) |
| **rmcp** | 0.5.0 | Model Context Protocol (server, transport-io) |

**rmcp 설정:**
```toml
rmcp = { version = "0.5.0", features = ["server", "transport-io"] }
```

**사용:**
```rust
use rmcp::{McpServer, Tool, ToolResult};

// MCP 서버 생성
let server = McpServer::new("anyon-mcp-server");

// 도구 등록
server.register_tool("list_projects", list_projects_handler);
```

### 1.9 유틸리티

#### **날짜/시간 & 식별자**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **chrono** | 0.4 | 날짜/시간 (serde 지원) |
| **uuid** | 1.0 | UUID v4 (serde 지원) |

#### **문자열 & 파싱**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **regex** | 1.11.1 | 정규 표현식 |
| **shlex** | 1.3.0 | 셸 렉싱 |
| **strip-ansi-escapes** | 0.2.1 | ANSI 코드 제거 |

#### **파일 & 디렉토리**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **tempfile** | - | 임시 파일/디렉토리 |
| **dirs** | 5.0 | 크로스 플랫폼 디렉토리 경로 |
| **directories** | 6.0.0 | XDG 준수 |
| **notify** | 8.2.0 | 파일 시스템 이벤트 |
| **notify-debouncer-full** | 0.5.0 | 디바운스된 이벤트 전달 |

#### **캐싱 & 성능**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **moka** | 0.12 | 고성능 캐시 (future 지원) |
| **fst** | 0.4 | Finite State Transducer (빠른 문자열 검색) |
| **dashmap** | 6.1 | 동시성 HashMap |
| **json-patch** | 2.0 | RFC 6902 JSON 패치 |
| **similar** | 2 | Diff 알고리즘 |

#### **설정 & 임베딩**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **toml** | 0.8 | TOML 파싱 |
| **rust-embed** | 8.2 | 정적 파일 임베딩 |
| **base64** | 0.22 | Base64 인코딩/디코딩 |
| **sha2** | 0.10 | SHA-2 해싱 |

#### **시스템 유틸리티**
| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **lazy_static** | 1.4 | 전역 정적 변수 |
| **backon** | 1.5.1 | 재시도 로직 |
| **open** | 5.3.2 | 파일/URL 열기 (브라우저 실행) |
| **shellexpand** | 3.1.1 | 셸 확장 (~/변수) |
| **which** | 8.0.0 | PATH에서 실행 파일 찾기 |

### 1.10 빌드 & 링킹

| 라이브러리 | 버전 | 용도 |
|-----------|------|-----|
| **openssl-sys** | 0.9 | OpenSSL 바인딩 (vendored) |
| **git2** | 0.18 | libgit2 C 라이브러리 포함 |
| **dotenv** | 0.15 | 빌드 시 .env 로딩 |

---

## 2. Crate 구성 및 의존성

### 2.1 Crate 의존성 그래프

```
┌─────────────────────────────────────────────────────────┐
│                 server (main binary)                    │
│  - Routes, API endpoints, MCP server, middleware        │
└─────────┬───────────────────────────────────────────────┘
          │
          ├──────────────────┬───────────────┬──────────────┬──────────┐
          │                  │               │              │          │
         db            deployment       services      executors    utils
    (Models, DB)   (Abstract trait) (Business logic) (AI agents) (Helpers)
    └─────────┘    └───────────────┘ └───────────────┘ └──────────┘ └────┘
          │              │                   │              │
          │              └───────────────────┼──────────────┘
          │                                  │
          └──────────────────────┬───────────┘
                                 │
                          local-deployment
                       (LocalDeployment impl)
```

### 2.2 각 Crate 상세

#### **2.2.1 crates/db - 데이터베이스 레이어**

**목적:** 모든 데이터 모델 및 데이터베이스 작업 정의

**의존성:**
```toml
[dependencies]
utils = { path = "../utils" }
executors = { path = "../executors" }
tokio = { version = "1.0", features = ["full"] }
sqlx = { version = "0.8.6", features = ["sqlite", "runtime-tokio-rustls", ...] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
ts-rs = { ... }
```

**모듈:**
```
src/
├── lib.rs                     # DBService 정의
└── models/                    # 11개 모델 파일
    ├── project.rs            # Project 구조체 & 쿼리
    ├── task.rs               # Task 구조체 & 쿼리
    ├── task_attempt.rs       # TaskAttempt 구조체 & 쿼리
    ├── execution_process.rs  # ExecutionProcess & 로그
    ├── executor_session.rs   # MCP executor 세션
    ├── draft.rs              # Draft 실행 데이터
    ├── tag.rs                # 사용자 태그
    ├── image.rs              # 이미지 메타데이터
    ├── merge.rs              # PR/병합 정보
    └── mod.rs                # 모듈 내보내기
```

**데이터베이스 기능:**
- **46개 마이그레이션 파일** (YYYYMMDDHHMMSS 형식)
- SQLite (외래 키 제약 조건 활성화)
- Enum을 CHECK 제약 조건으로
- 복잡한 데이터용 JSON 열
- 서브초 정밀도 타임스탬프

**주요 패턴:**
```rust
// 모델 구조체의 비동기 쿼리 메서드
impl Task {
    pub async fn find_by_id(
        pool: &SqlitePool,
        id: Uuid,
    ) -> Result<Option<Task>> {
        sqlx::query_as!(
            Task,
            r#"SELECT * FROM tasks WHERE id = ?"#,
            id
        )
        .fetch_optional(pool)
        .await
    }
}
```

#### **2.2.2 crates/executors - AI 에이전트 Executor 시스템**

**목적:** 플러그 가능한 AI 에이전트 executor 및 액션 실행 구현

**의존성:**
```toml
[dependencies]
workspace_utils = { path = "../utils" }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
ts-rs = { ... }
async-trait = "0.1"
enum_dispatch = "0.3"
```

**서브모듈:**
```
src/
├── executors/                # 개별 executor 구현
│   ├── claude.rs            # Claude (2303 라인)
│   ├── cursor.rs            # Cursor IDE
│   ├── codex.rs             # OpenAI Codex
│   ├── copilot.rs           # GitHub Copilot
│   ├── gemini.rs            # Google Gemini
│   ├── amp.rs               # AMP executor
│   ├── opencode.rs          # OpenCode
│   ├── qwen.rs              # Qwen
│   └── acp/                 # ACP executor 서브디렉토리
│
├── actions/                 # 액션 타입 정의
│   ├── coding_agent_initial.rs     # 초기 코딩 작업
│   ├── coding_agent_follow_up.rs   # 후속 코딩 작업
│   ├── script.rs                   # 스크립트 실행
│   └── mod.rs                      # ExecutorAction enum (enum_dispatch)
│
├── profile.rs               # Executor 프로파일 & 기능
├── logs/                    # 로그 처리 유틸리티
├── command.rs               # 프로세스 생성 헬퍼
├── mcp_config.rs            # MCP 설정 생성
├── approvals.rs             # 승인/확인 시스템
└── stdout_dup.rs            # Stdout 중복 로깅용
```

**패턴:**
```rust
// 트레이트 기반 executor 인터페이스
#[async_trait]
pub trait Executor {
    async fn execute_initial_request(
        &self,
        request: CodingAgentInitialRequest,
    ) -> Result<ExecutorResult>;

    async fn execute_follow_up(
        &self,
        request: CodingAgentFollowUpRequest,
    ) -> Result<ExecutorResult>;
}

// enum_dispatch로 vtable 없는 다형성
#[enum_dispatch]
pub enum ExecutorAction {
    CodingAgentInitial(CodingAgentInitialAction),
    CodingAgentFollowUp(CodingAgentFollowUpAction),
    Script(ScriptAction),
}
```

#### **2.2.3 crates/services - 비즈니스 로직 레이어**

**목적:** 고수준 비즈니스 로직 및 외부 통합

**의존성:**
```toml
[dependencies]
utils = { path = "../utils" }
executors = { path = "../executors" }
db = { path = "../db" }
tokio = { version = "1.0", features = ["full"] }
axum = "0.8.4"
git2 = "0.18"
reqwest = { version = "0.12", features = ["json"] }
octocrab = "0.44"
notify = "8.2.0"
```

**주요 서비스 (24개 모듈):**
```
src/services/
├── auth.rs                    # GitHub OAuth device flow (198 LOC)
├── git.rs                     # Git 작업 (2036 LOC)
├── git_cli.rs                 # Git CLI 래퍼
├── github_service.rs          # GitHub API 통합
├── worktree_manager.rs        # Git 워크트리 격리
├── container.rs               # 프로세스 실행 컨테이너 (818 LOC)
├── drafts.rs                  # 임시 실행 관리
├── events.rs                  # 실시간 스트리밍 업데이트
│   ├── patches.rs            # Diff용 JSON patch
│   ├── streams.rs            # 이벤트 스트리밍 로직
│   └── types.rs              # 이벤트 타입 정의
├── file_search_cache.rs       # FST 인덱싱 파일 검색
├── file_ranker.rs             # 스마트 파일 랭킹
├── filesystem.rs              # 파일 작업
├── filesystem_watcher.rs      # 파일 변경 감시
├── diff_stream.rs             # Diff 변경 스트리밍
├── image.rs                   # 이미지/스크린샷 저장
├── config.rs                  # 사용자 설정
├── analytics.rs               # 분석 추적
├── approvals.rs               # 승인 워크플로우
├── pr_monitor.rs              # PR 상태 모니터링
└── notification.rs            # 시스템 알림
```

**주요 패턴:**
- Tokio로 Async/await
- 제네릭 트레이트 기반 아키텍쳐
- thiserror로 에러 체이닝
- 대형 작업용 스트리밍

**예시: GitService 주요 작업**
```rust
impl GitService {
    // 워크트리 생성
    pub async fn create_worktree(
        &self,
        repo_path: &Path,
        branch: &str,
        worktree_path: &Path,
    ) -> Result<()> { ... }

    // Diff 생성
    pub async fn get_diff(
        &self,
        repo_path: &Path,
        base_branch: &str,
        compare_branch: &str,
    ) -> Result<Vec<Diff>> { ... }

    // 충돌 감지
    pub async fn get_conflicts(
        &self,
        repo_path: &Path,
    ) -> Result<Vec<Conflict>> { ... }
}
```

#### **2.2.4 crates/server - HTTP 서버 & API 라우트**

**목적:** Axum HTTP 서버, REST API 엔드포인트, MCP 통합

**의존성:**
```toml
[dependencies]
# 모든 다른 crate
axum = { version = "0.8.4", features = ["macros", "multipart", "ws"] }
rmcp = { version = "0.5.0", features = ["server", "transport-io"] }
tokio = { version = "1.0", features = ["full"] }
git2 = "0.18"
```

**구조:**
```
server/src/
├── main.rs                  # 진입점, 서버 설정, 포트 바인딩
├── lib.rs                   # 모듈 내보내기
├── error.rs                 # ApiError 타입 (모든 도메인 에러 변환)
├── mcp/                     # MCP 서버 구현
│   ├── mod.rs
│   └── task_server.rs      # 작업 관리용 MCP 도구 (150+ 라인)
├── middleware/              # HTTP 미들웨어
│   ├── mod.rs
│   └── model_loaders.rs    # 모델 로딩 미들웨어
└── routes/                  # API 엔드포인트 구현 (20개 라우트 파일)
    ├── mod.rs                      # 라우터 컴포지션, /api nest
    ├── health.rs                   # 헬스 체크 엔드포인트
    ├── projects.rs                 # 프로젝트 CRUD + 검색
    ├── tasks.rs                    # 작업 CRUD
    ├── task_attempts.rs            # 시도 라이프사이클 (4500+ 라인)
    ├── execution_processes.rs      # 프로세스 스트리밍 (WebSocket + SSE)
    ├── events.rs                   # 이벤트 SSE 스트리밍
    ├── auth.rs                     # GitHub OAuth device flow
    ├── config.rs                   # 설정 관리
    ├── containers.rs               # 컨테이너 작업
    ├── filesystem.rs               # 파일 작업
    ├── images.rs                   # 이미지 업로드/검색
    ├── drafts.rs                   # Draft 관리
    ├── tags.rs                     # 태그 관리
    ├── approvals.rs                # 승인 엔드포인트
    └── task_attempts/              # 시도용 서브 라우트
```

**주요 패턴:**
```rust
// merge()로 라우터 컴포지션
let app = Router::new()
    .merge(projects::routes())
    .merge(tasks::routes())
    .merge(task_attempts::routes())
    .with_state(deployment);

// axum State<DeploymentImpl>로 상태 관리
async fn create_project(
    State(deployment): State<Arc<LocalDeployment>>,
    Json(data): Json<CreateProject>,
) -> Result<Json<Project>, ApiError> { ... }

// 로드된 모델용 Extension extractor (Project, Task 등)
async fn update_task(
    Extension(task): Extension<Task>,
    Json(updates): Json<UpdateTask>,
) -> Result<Json<Task>, ApiError> { ... }

// IntoResponse를 통한 에러 변환
impl IntoResponse for ApiError {
    fn into_response(self) -> Response { ... }
}
```

#### **2.2.5 crates/local-deployment**

**목적:** 로컬 개발용 Deployment 트레이트의 구체적 구현

**의존성:**
```toml
[dependencies]
deployment = { path = "../deployment" }
db = { path = "../db" }
services = { path = "../services" }
executors = { path = "../executors" }
utils = { path = "../utils" }
```

**컴포넌트:**
```
src/
├── lib.rs         # LocalDeployment 구조체 & Deployment 트레이트 impl
├── container.rs   # LocalContainerService 트레이트 구현
└── command.rs     # 커맨드 실행 유틸리티
```

**LocalDeployment 초기화:**
```rust
impl LocalDeployment {
    pub async fn new() -> Result<Self> {
        // TOML에서 설정 로드
        let config = load_config()?;

        // 이벤트 훅으로 데이터베이스 초기화
        let db_service = DBService::new_with_after_connect(hook).await?;

        // 모든 서비스 설정 (Git, Auth, Image 등)
        let services = Services::new(...);

        // 백그라운드 작업 시작 (이미지 정리, 파일 캐시 워밍)
        spawn_background_tasks();

        // 고유 사용자 ID 생성
        let analytics_user_id = generate_user_id();

        Ok(Self { config, db_service, services, ... })
    }
}
```

#### **2.2.6 crates/utils - 공유 유틸리티**

**목적:** crate 간 사용되는 공통 유틸리티 및 헬퍼

**의존성:**
```toml
[dependencies]
tokio = { version = "1.0", features = ["full"] }
axum = "0.8.4"
git2 = "0.18"
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
sentry = "0.41.0"
```

**모듈:**
```
src/
├── assets.rs        # 임베디드 자산 관리
├── browser.rs       # 브라우저 실행
├── diff.rs          # Diff 구조체 및 유틸리티
├── git.rs           # Git 관련 헬퍼
├── log_msg.rs       # 로그 메시지 타입
├── msg_store.rs     # 스레드 안전 메시지 저장소
├── path.rs          # 경로 유틸리티 (expand_tilde)
├── port_file.rs     # 포트 검색 파일
├── response.rs      # ApiResponse 래퍼 구조체
├── sentry.rs        # Sentry 통합 및 설정
├── shell.rs         # 셸 커맨드 유틸리티
├── stream_ext.rs    # 스트림 확장 트레이트
├── stream_lines.rs  # 라인 기반 스트림 처리
├── text.rs          # 텍스트 유틸리티 (git 브랜치 ID, 짧은 UUID)
└── version.rs       # 버전 상수
```

#### **2.2.7 crates/deployment - Abstract Deployment 트레이트**

**목적:** 구현에 대한 추상화를 위해 Deployment 트레이트 정의

**Deployment 트레이트 제공:**
```rust
#[async_trait]
pub trait Deployment {
    // 데이터베이스 초기화
    fn db_service(&self) -> &DBService;

    // 서비스 인스턴스화
    fn git_service(&self) -> &GitService;
    fn github_service(&self) -> &GitHubService;
    fn container_service(&self) -> &dyn ContainerService;

    // 분석 추적
    fn track_event(&self, event: AnalyticsEvent);

    // PR 모니터링
    fn start_pr_monitor(&self, attempt_id: Uuid);

    // 워크트리 정리
    fn cleanup_orphaned_worktrees(&self);

    // 포트 파일 쓰기
    fn write_port_file(&self, port: u16);
}
```

---

## 3. 서버 아키텍쳐 (crates/server)

### 3.1 Axum 서버 설정

**main.rs:**
```rust
#[tokio::main]
async fn main() -> Result<()> {
    // 로깅 초기화
    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .init();

    // LocalDeployment 생성
    let deployment = Arc::new(LocalDeployment::new().await?);

    // 라우터 구축
    let app = Router::new()
        .route("/api/health", get(health::health_check))
        .merge(projects::routes())
        .merge(tasks::routes())
        .merge(task_attempts::routes())
        .merge(execution_processes::routes())
        .merge(events::routes())
        .merge(auth::routes())
        .merge(config::routes())
        .layer(
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any)
                .allow_headers(Any)
        )
        .with_state(deployment.clone());

    // 포트 바인딩 (0 = auto-assign)
    let port = std::env::var("BACKEND_PORT")
        .ok()
        .and_then(|p| p.parse().ok())
        .unwrap_or(0);

    let addr = SocketAddr::from(([127, 0, 0, 1], port));
    let listener = TcpListener::bind(addr).await?;
    let actual_port = listener.local_addr()?.port();

    tracing::info!("Server listening on http://127.0.0.1:{}", actual_port);

    // 포트 파일 쓰기
    deployment.write_port_file(actual_port);

    // 서버 시작
    axum::serve(listener, app).await?;

    Ok(())
}
```

### 3.2 라우트 조직

**routes/mod.rs:**
```rust
pub fn routes() -> Router<Arc<LocalDeployment>> {
    Router::new()
        .nest("/api", api_routes())
        .nest("/auth", auth::routes())
}

fn api_routes() -> Router<Arc<LocalDeployment>> {
    Router::new()
        .merge(projects::routes())
        .merge(tasks::routes())
        .merge(task_attempts::routes())
        .merge(execution_processes::routes())
        .merge(events::routes())
        .merge(config::routes())
        .merge(containers::routes())
        .merge(filesystem::routes())
        .merge(images::routes())
        .merge(drafts::routes())
        .merge(tags::routes())
        .merge(approvals::routes())
}
```

### 3.3 미들웨어 스택

**인증 미들웨어:**
```rust
async fn auth_middleware(
    State(deployment): State<Arc<LocalDeployment>>,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // 토큰 검증
    // ...
    Ok(next.run(request).await)
}
```

**모델 로더 미들웨어:**
```rust
// Project ID를 경로에서 로드하고 Extension에 삽입
async fn load_project(
    State(deployment): State<Arc<LocalDeployment>>,
    Path(project_id): Path<Uuid>,
    mut request: Request,
    next: Next,
) -> Result<Response, ApiError> {
    let project = Project::find_by_id(deployment.db_service().pool(), project_id)
        .await?
        .ok_or(ApiError::NotFound)?;

    request.extensions_mut().insert(project);

    Ok(next.run(request).await)
}
```

### 3.4 에러 처리

**error.rs:**
```rust
#[derive(Debug)]
pub struct ApiError {
    pub status: StatusCode,
    pub message: String,
    pub error_data: Option<serde_json::Value>,
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = Json(json!({
            "success": false,
            "message": self.message,
            "error_data": self.error_data,
        }));

        (self.status, body).into_response()
    }
}

// 도메인 에러에서 변환
impl From<GitServiceError> for ApiError {
    fn from(err: GitServiceError) -> Self {
        ApiError {
            status: StatusCode::INTERNAL_SERVER_ERROR,
            message: err.to_string(),
            error_data: None,
        }
    }
}
```

### 3.5 요청/응답 플로우

```
클라이언트 요청
    │
    ▼
Axum 라우터 매칭
    │
    ▼
미들웨어 (CORS, 인증, 모델 로딩)
    │
    ▼
핸들러 함수
    │
    ├─→ State에서 Deployment 추출
    ├─→ 경로/쿼리에서 매개변수 추출
    ├─→ Extension에서 모델 추출
    ├─→ 본문 역직렬화 (Json)
    │
    ▼
비즈니스 로직 실행
    │
    ├─→ 서비스 호출
    ├─→ 데이터베이스 쿼리
    ├─→ 외부 API 호출
    │
    ▼
응답 직렬화
    │
    ├─→ Result<Json<T>, ApiError>
    ├─→ IntoResponse 구현
    │
    ▼
클라이언트로 HTTP 응답
```

---

## 4. API 설계

### 4.1 REST API 엔드포인트

#### **프로젝트 엔드포인트**
```rust
// GET /api/projects
async fn list_projects(
    State(deployment): State<Arc<LocalDeployment>>,
) -> Result<Json<Vec<Project>>, ApiError> {
    let projects = Project::find_all(deployment.db_service().pool()).await?;
    Ok(Json(projects))
}

// POST /api/projects
async fn create_project(
    State(deployment): State<Arc<LocalDeployment>>,
    Json(data): Json<CreateProject>,
) -> Result<Json<Project>, ApiError> {
    let project = Project::create(deployment.db_service().pool(), data).await?;
    Ok(Json(project))
}

// GET /api/projects/{id}
async fn get_project(
    Extension(project): Extension<Project>,
) -> Json<Project> {
    Json(project)
}

// PUT /api/projects/{id}
async fn update_project(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(project): Extension<Project>,
    Json(updates): Json<UpdateProject>,
) -> Result<Json<Project>, ApiError> {
    let updated = project.update(deployment.db_service().pool(), updates).await?;
    Ok(Json(updated))
}

// DELETE /api/projects/{id}
async fn delete_project(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(project): Extension<Project>,
) -> Result<StatusCode, ApiError> {
    project.delete(deployment.db_service().pool()).await?;
    Ok(StatusCode::NO_CONTENT)
}

// POST /api/projects/{id}/open-editor
async fn open_editor(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(project): Extension<Project>,
    Json(data): Json<OpenEditorRequest>,
) -> Result<StatusCode, ApiError> {
    deployment.open_project_in_editor(&project, data.editor).await?;
    Ok(StatusCode::OK)
}

// GET /api/projects/{id}/branches
async fn get_branches(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(project): Extension<Project>,
) -> Result<Json<Vec<Branch>>, ApiError> {
    let branches = deployment.git_service().get_branches(&project.git_repo_path).await?;
    Ok(Json(branches))
}

// GET /api/projects/{id}/search-files?q=...
async fn search_files(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(project): Extension<Project>,
    Query(params): Query<SearchFilesQuery>,
) -> Result<Json<Vec<FileSearchResult>>, ApiError> {
    let results = deployment.file_search_cache()
        .search(&project.id, &params.query)
        .await?;
    Ok(Json(results))
}
```

#### **작업 엔드포인트**
```rust
// GET /api/tasks?project_id={projectId}
async fn list_tasks(
    State(deployment): State<Arc<LocalDeployment>>,
    Query(params): Query<ListTasksQuery>,
) -> Result<Json<Vec<TaskWithAttemptStatus>>, ApiError> {
    let tasks = Task::find_by_project_id_with_status(
        deployment.db_service().pool(),
        params.project_id
    ).await?;
    Ok(Json(tasks))
}

// POST /api/tasks
async fn create_task(
    State(deployment): State<Arc<LocalDeployment>>,
    Json(data): Json<CreateTask>,
) -> Result<Json<Task>, ApiError> {
    let task = Task::create(deployment.db_service().pool(), data).await?;
    Ok(Json(task))
}

// GET /api/tasks/{id}
async fn get_task(
    Extension(task): Extension<Task>,
) -> Json<Task> {
    Json(task)
}

// PUT /api/tasks/{id}
async fn update_task(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(task): Extension<Task>,
    Json(updates): Json<UpdateTask>,
) -> Result<Json<Task>, ApiError> {
    let updated = task.update(deployment.db_service().pool(), updates).await?;
    Ok(Json(updated))
}

// DELETE /api/tasks/{id}
async fn delete_task(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(task): Extension<Task>,
) -> Result<StatusCode, ApiError> {
    task.delete(deployment.db_service().pool()).await?;
    Ok(StatusCode::NO_CONTENT)
}
```

#### **작업 시도 엔드포인트**
```rust
// POST /api/task-attempts
async fn create_attempt(
    State(deployment): State<Arc<LocalDeployment>>,
    Json(data): Json<CreateTaskAttempt>,
) -> Result<Json<TaskAttempt>, ApiError> {
    // 1. TaskAttempt 레코드 생성
    let attempt = TaskAttempt::create(deployment.db_service().pool(), data).await?;

    // 2. Git 워크트리 생성
    deployment.worktree_manager().create_worktree(
        &attempt.project.git_repo_path,
        &attempt.branch,
        &attempt.worktree_path,
    ).await?;

    // 3. 실행 프로세스 생성
    deployment.container_service().start_process(
        &attempt,
        ExecutorAction::CodingAgentInitial(data.into()),
    ).await?;

    Ok(Json(attempt))
}

// GET /api/task-attempts/{id}
async fn get_attempt(
    Extension(attempt): Extension<TaskAttempt>,
) -> Json<TaskAttempt> {
    Json(attempt)
}

// POST /api/task-attempts/{id}/merge
async fn merge_attempt(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(attempt): Extension<TaskAttempt>,
) -> Result<Json<MergeResult>, ApiError> {
    let result = deployment.git_service().merge(
        &attempt.project.git_repo_path,
        &attempt.branch,
        &attempt.target_branch,
    ).await?;

    // 워크트리 정리
    deployment.worktree_manager().cleanup_worktree(&attempt).await?;

    Ok(Json(result))
}

// POST /api/task-attempts/{id}/create-pr
async fn create_pr(
    State(deployment): State<Arc<LocalDeployment>>,
    Extension(attempt): Extension<TaskAttempt>,
    Json(data): Json<CreatePrRequest>,
) -> Result<Json<PullRequest>, ApiError> {
    let pr = deployment.github_service().create_pull_request(
        &attempt.project.repository,
        &attempt.branch,
        &attempt.target_branch,
        &data.title,
        &data.body,
    ).await?;

    Ok(Json(pr))
}
```

### 4.2 Server-Sent Events (SSE) 엔드포인트

```rust
// GET /api/events/processes/{processId}/logs
async fn stream_process_logs(
    State(deployment): State<Arc<LocalDeployment>>,
    Path(process_id): Path<Uuid>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let stream = deployment.event_service()
        .subscribe_process_logs(process_id);

    Sse::new(stream.map(|log| {
        Ok(Event::default().data(log.content))
    }))
}

// GET /api/events/task-attempts/{attemptId}/diff
async fn stream_attempt_diffs(
    State(deployment): State<Arc<LocalDeployment>>,
    Path(attempt_id): Path<Uuid>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let stream = deployment.event_service()
        .subscribe_attempt_diffs(attempt_id);

    Sse::new(stream.map(|patch| {
        Ok(Event::default().json_data(patch).unwrap())
    }))
}

// GET /api/events/{entityType}/{entityId}
async fn stream_entity_updates(
    State(deployment): State<Arc<LocalDeployment>>,
    Path((entity_type, entity_id)): Path<(String, Uuid)>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let stream = deployment.event_service()
        .subscribe_entity_updates(&entity_type, entity_id);

    Sse::new(stream.map(|patch| {
        Ok(Event::default().json_data(patch).unwrap())
    }))
}
```

### 4.3 요청/응답 타입

**요청 타입 (ts-rs로 생성):**
```rust
#[derive(Debug, Deserialize, TS)]
#[ts(export)]
pub struct CreateTask {
    pub project_id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub parent_task_attempt: Option<Uuid>,
}

#[derive(Debug, Deserialize, TS)]
#[ts(export)]
pub struct CreateTaskAttempt {
    pub task_id: Uuid,
    pub executor: String,
    pub base_branch: String,
    pub prompt: String,
    pub variant: Option<String>,
}

#[derive(Debug, Deserialize, TS)]
#[ts(export)]
pub struct UpdateTask {
    pub title: Option<String>,
    pub description: Option<String>,
    pub status: Option<TaskStatus>,
}
```

**응답 타입:**
```rust
#[derive(Debug, Serialize, TS)]
#[ts(export)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub message: Option<String>,
    pub error_data: Option<serde_json::Value>,
}
```

---

## 5. 데이터베이스 레이어 (crates/db)

### 5.1 데이터베이스 스키마

#### **projects 테이블**
```sql
CREATE TABLE projects (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    git_repo_path TEXT NOT NULL,
    setup_script TEXT,
    dev_script TEXT,
    cleanup_script TEXT,
    copy_files TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);
```

#### **tasks 테이블**
```sql
CREATE TABLE tasks (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL CHECK(status IN (
        'todo', 'inprogress', 'inreview', 'done', 'cancelled'
    )),
    parent_task_attempt TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY(parent_task_attempt) REFERENCES task_attempts(id) ON DELETE SET NULL
);
```

#### **task_attempts 테이블**
```sql
CREATE TABLE task_attempts (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    branch TEXT NOT NULL,
    target_branch TEXT NOT NULL,
    executor TEXT NOT NULL,
    container_ref TEXT,
    worktree_deleted INTEGER NOT NULL DEFAULT 0,
    setup_completed_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(task_id) REFERENCES tasks(id) ON DELETE CASCADE
);
```

#### **execution_processes 테이블**
```sql
CREATE TABLE execution_processes (
    id TEXT PRIMARY KEY,
    task_attempt_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK(status IN (
        'running', 'success', 'failed', 'killed'
    )),
    run_reason TEXT NOT NULL CHECK(run_reason IN (
        'CodeAgent', 'SetupScript', 'CleanupScript', 'DevServer'
    )),
    executor_type TEXT NOT NULL,
    exit_code INTEGER,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    completed_at TEXT,
    FOREIGN KEY(task_attempt_id) REFERENCES task_attempts(id) ON DELETE CASCADE
);
```

### 5.2 SQLx 쿼리 패턴

**컴파일 타임 검증 쿼리:**
```rust
// query_as! 매크로 - 컴파일 시 유효성 검사
pub async fn find_by_id(
    pool: &SqlitePool,
    id: Uuid,
) -> Result<Option<Task>> {
    let task = sqlx::query_as!(
        Task,
        r#"
        SELECT
            id as "id!: Uuid",
            project_id as "project_id!: Uuid",
            title,
            description,
            status as "status!: TaskStatus",
            parent_task_attempt as "parent_task_attempt: Uuid",
            created_at as "created_at!: DateTime<Utc>",
            updated_at as "updated_at!: DateTime<Utc>"
        FROM tasks
        WHERE id = ?
        "#,
        id
    )
    .fetch_optional(pool)
    .await?;

    Ok(task)
}
```

**동적 쿼리:**
```rust
pub async fn find_by_filters(
    pool: &SqlitePool,
    filters: TaskFilters,
) -> Result<Vec<Task>> {
    let mut query = QueryBuilder::new("SELECT * FROM tasks WHERE 1=1");

    if let Some(project_id) = filters.project_id {
        query.push(" AND project_id = ");
        query.push_bind(project_id);
    }

    if let Some(status) = filters.status {
        query.push(" AND status = ");
        query.push_bind(status);
    }

    let tasks = query
        .build_query_as::<Task>()
        .fetch_all(pool)
        .await?;

    Ok(tasks)
}
```

### 5.3 모델 메서드 패턴

```rust
impl Task {
    // 생성
    pub async fn create(
        pool: &SqlitePool,
        data: CreateTask,
    ) -> Result<Task> {
        let id = Uuid::new_v4();
        let now = Utc::now();

        sqlx::query!(
            r#"
            INSERT INTO tasks (id, project_id, title, description, status, created_at, updated_at)
            VALUES (?, ?, ?, ?, 'todo', ?, ?)
            "#,
            id,
            data.project_id,
            data.title,
            data.description,
            now,
            now,
        )
        .execute(pool)
        .await?;

        Self::find_by_id(pool, id).await?.ok_or(anyhow!("Task not found"))
    }

    // 업데이트
    pub async fn update(
        &self,
        pool: &SqlitePool,
        updates: UpdateTask,
    ) -> Result<Task> {
        let now = Utc::now();

        sqlx::query!(
            r#"
            UPDATE tasks
            SET
                title = COALESCE(?, title),
                description = COALESCE(?, description),
                status = COALESCE(?, status),
                updated_at = ?
            WHERE id = ?
            "#,
            updates.title,
            updates.description,
            updates.status,
            now,
            self.id,
        )
        .execute(pool)
        .await?;

        Self::find_by_id(pool, self.id).await?.ok_or(anyhow!("Task not found"))
    }

    // 삭제
    pub async fn delete(
        &self,
        pool: &SqlitePool,
    ) -> Result<()> {
        sqlx::query!("DELETE FROM tasks WHERE id = ?", self.id)
            .execute(pool)
            .await?;

        Ok(())
    }
}
```

### 5.4 마이그레이션 전략

**마이그레이션 파일 형식:**
```
migrations/
├── 20250617183714_init.sql
├── 20250620212427_execution_processes.sql
├── 20250623120000_executor_sessions.sql
├── 20250715154859_add_task_templates.sql
└── 20250716161432_update_executor_names.sql
```

**마이그레이션 실행:**
```rust
// main.rs에서
let pool = SqlitePool::connect(&database_url).await?;
sqlx::migrate!("./migrations").run(&pool).await?;
```

**규칙:**
1. 기존 마이그레이션 절대 수정 금지
2. 각 스키마 변경마다 새 마이그레이션 생성
3. YYYYMMDDHHMMSS 타임스탬프 형식 사용
4. `sqlx migrate add description` 사용

### 5.5 Preupdate Hook

**EventService::create_hook():**
```rust
pub fn create_hook(
    msg_store: Arc<MsgStore>,
    entry_count: Arc<AtomicUsize>,
    db_service: Arc<DBService>,
) -> impl Fn(&mut Connection) -> Result<(), BoxDynError> + Send + Sync + 'static {
    move |conn: &mut Connection| {
        conn.preupdate_hook(Some(move |action, db, table, old_rowid, new_rowid| {
            // OLD 및 NEW 값 캡처
            let old_value = get_row_value(conn, db, table, old_rowid);
            let new_value = get_row_value(conn, db, table, new_rowid);

            // JSON Patch 생성
            let patch = generate_json_patch(old_value, new_value);

            // MsgStore에 푸시
            msg_store.push(table, patch);
        }));

        Ok(())
    }
}
```

---

## 6. 비즈니스 로직 (crates/services)

### 6.1 GitService (2036 LOC)

**주요 작업:**

**워크트리 관리:**
```rust
impl GitService {
    pub async fn create_worktree(
        &self,
        repo_path: &Path,
        branch: &str,
        target_branch: &str,
        worktree_path: &Path,
    ) -> Result<()> {
        let repo = Repository::open(repo_path)?;

        // 브랜치 생성
        let target_commit = repo.find_branch(target_branch, BranchType::Local)?
            .get()
            .peel_to_commit()?;

        repo.branch(branch, &target_commit, false)?;

        // 워크트리 추가
        let mut opts = WorktreeAddOptions::new();
        opts.reference(Some(branch));

        repo.worktree(
            branch,
            worktree_path,
            Some(&mut opts),
        )?;

        Ok(())
    }

    pub async fn cleanup_worktree(
        &self,
        repo_path: &Path,
        branch: &str,
        worktree_path: &Path,
    ) -> Result<()> {
        let repo = Repository::open(repo_path)?;

        // 워크트리 제거
        let worktree = repo.find_worktree(branch)?;
        worktree.prune(None)?;

        // 디렉토리 삭제
        std::fs::remove_dir_all(worktree_path)?;

        // 브랜치 삭제
        let mut branch = repo.find_branch(branch, BranchType::Local)?;
        branch.delete()?;

        Ok(())
    }
}
```

**Diff 생성:**
```rust
impl GitService {
    pub async fn get_diff(
        &self,
        repo_path: &Path,
        base_branch: &str,
        compare_branch: &str,
    ) -> Result<Vec<Diff>> {
        let repo = Repository::open(repo_path)?;

        // 트리 가져오기
        let base_tree = repo.find_branch(base_branch, BranchType::Local)?
            .get()
            .peel_to_tree()?;

        let compare_tree = repo.find_branch(compare_branch, BranchType::Local)?
            .get()
            .peel_to_tree()?;

        // Diff 생성
        let diff = repo.diff_tree_to_tree(
            Some(&base_tree),
            Some(&compare_tree),
            None,
        )?;

        // Diff를 Diff 구조체로 변환
        let diffs = convert_git_diff_to_diffs(diff)?;

        Ok(diffs)
    }
}
```

**Merge 작업:**
```rust
impl GitService {
    pub async fn merge(
        &self,
        repo_path: &Path,
        source_branch: &str,
        target_branch: &str,
    ) -> Result<MergeResult> {
        let repo = Repository::open(repo_path)?;

        // 타겟 브랜치 체크아웃
        checkout_branch(&repo, target_branch)?;

        // Merge 수행
        let source_commit = repo.find_branch(source_branch, BranchType::Local)?
            .get()
            .peel_to_commit()?;

        let mut index = repo.merge_commits(
            &repo.head()?.peel_to_commit()?,
            &source_commit,
            None,
        )?;

        // 충돌 확인
        if index.has_conflicts() {
            let conflicts = get_conflicts(&index)?;
            return Ok(MergeResult::Conflicts(conflicts));
        }

        // 커밋 생성
        let tree_id = index.write_tree_to(&repo)?;
        let tree = repo.find_tree(tree_id)?;

        let signature = repo.signature()?;
        repo.commit(
            Some("HEAD"),
            &signature,
            &signature,
            &format!("Merge {} into {}", source_branch, target_branch),
            &tree,
            &[&repo.head()?.peel_to_commit()?, &source_commit],
        )?;

        Ok(MergeResult::Success)
    }
}
```

### 6.2 ContainerService (818 LOC)

**프로세스 실행:**
```rust
impl LocalContainerService {
    pub async fn start_process(
        &self,
        attempt: &TaskAttempt,
        action: ExecutorAction,
    ) -> Result<ExecutionProcess> {
        // ExecutionProcess 레코드 생성
        let process = ExecutionProcess::create(
            self.db_service.pool(),
            CreateExecutionProcess {
                task_attempt_id: attempt.id,
                executor_type: action.executor_type(),
                run_reason: action.run_reason(),
            },
        ).await?;

        // 커맨드 빌드
        let command = action.build_command(&attempt.worktree_path)?;

        // 프로세스 생성
        let mut child = CommandGroup::new(command)
            .cwd(&attempt.worktree_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        // Stdout/stderr 캡처
        let process_id = process.id;
        let db_service = self.db_service.clone();

        tokio::spawn(async move {
            capture_output(child, process_id, db_service).await
        });

        Ok(process)
    }
}

async fn capture_output(
    mut child: Child,
    process_id: Uuid,
    db_service: Arc<DBService>,
) -> Result<()> {
    let stdout = child.stdout.take().unwrap();
    let stderr = child.stderr.take().unwrap();

    // 스트림 읽기
    let mut stdout_lines = BufReader::new(stdout).lines();
    let mut stderr_lines = BufReader::new(stderr).lines();

    loop {
        tokio::select! {
            line = stdout_lines.next_line() => {
                if let Some(line) = line? {
                    save_log(db_service.pool(), process_id, "STDOUT", line).await?;
                } else {
                    break;
                }
            }
            line = stderr_lines.next_line() => {
                if let Some(line) = line? {
                    save_log(db_service.pool(), process_id, "STDERR", line).await?;
                }
            }
        }
    }

    // 프로세스 완료 대기
    let status = child.wait().await?;

    // 프로세스 상태 업데이트
    ExecutionProcess::update_status(
        db_service.pool(),
        process_id,
        if status.success() { "success" } else { "failed" },
        status.code(),
    ).await?;

    Ok(())
}
```

### 6.3 WorktreeManager

**경쟁 조건 방지:**
```rust
lazy_static! {
    static ref WORKTREE_CREATION_LOCKS: Arc<Mutex<HashMap<String, Arc<Mutex<()>>>>> =
        Arc::new(Mutex::new(HashMap::new()));
}

impl WorktreeManager {
    pub async fn create_worktree(
        &self,
        repo_path: &Path,
        branch: &str,
        worktree_path: &Path,
    ) -> Result<()> {
        // 저장소별 락 획득
        let lock = {
            let mut locks = WORKTREE_CREATION_LOCKS.lock().unwrap();
            locks.entry(repo_path.to_string_lossy().to_string())
                .or_insert_with(|| Arc::new(Mutex::new(())))
                .clone()
        };

        let _guard = lock.lock().await;

        // 워크트리 생성 (락 보호 하에)
        self.git_service.create_worktree(repo_path, branch, worktree_path).await?;

        Ok(())
    }
}
```

### 6.4 FileSearchCache

**FST 인덱싱:**
```rust
pub struct FileSearchCache {
    cache: Moka<Uuid, Arc<FileSearchIndex>>,
    db_service: Arc<DBService>,
}

pub struct FileSearchIndex {
    fst: fst::Map<Vec<u8>>,
    files: Vec<FileEntry>,
}

impl FileSearchCache {
    pub async fn search(
        &self,
        project_id: Uuid,
        query: &str,
    ) -> Result<Vec<FileSearchResult>> {
        // 캐시 확인
        let index = if let Some(index) = self.cache.get(&project_id) {
            index
        } else {
            // 인덱스 구축 및 캐시
            let index = self.build_index(project_id).await?;
            self.cache.insert(project_id, index.clone());
            index
        };

        // FST 검색
        let mut results = Vec::new();
        let matcher = fst::automaton::Levenshtein::new(query, 2)?;

        for result in index.fst.search(matcher).into_stream() {
            let (key, value) = result?;
            let file = &index.files[value as usize];
            results.push(FileSearchResult {
                path: file.path.clone(),
                score: calculate_score(key, query, file),
            });
        }

        // 점수로 정렬
        results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());

        Ok(results)
    }

    async fn build_index(&self, project_id: Uuid) -> Result<Arc<FileSearchIndex>> {
        let project = Project::find_by_id(self.db_service.pool(), project_id)
            .await?
            .ok_or(anyhow!("Project not found"))?;

        // 파일 수집
        let mut files = Vec::new();
        let walker = WalkBuilder::new(&project.git_repo_path)
            .hidden(false)
            .ignore(true)
            .build();

        for entry in walker {
            let entry = entry?;
            if entry.file_type().unwrap().is_file() {
                files.push(FileEntry {
                    path: entry.path().to_path_buf(),
                    last_modified: entry.metadata()?.modified()?,
                });
            }
        }

        // FST 구축
        let mut builder = fst::MapBuilder::memory();
        for (idx, file) in files.iter().enumerate() {
            let key = file.path.to_string_lossy();
            builder.insert(key.as_bytes(), idx as u64)?;
        }

        let fst = fst::Map::new(builder.into_inner()?)?;

        Ok(Arc::new(FileSearchIndex { fst, files }))
    }
}
```

---

## 7. AI Executor 시스템 (crates/executors)

### 7.1 Executor 트레이트

```rust
#[async_trait]
pub trait Executor: Send + Sync {
    async fn execute_initial_request(
        &self,
        request: CodingAgentInitialRequest,
    ) -> Result<ExecutorResult>;

    async fn execute_follow_up(
        &self,
        request: CodingAgentFollowUpRequest,
    ) -> Result<ExecutorResult>;

    fn executor_type(&self) -> String;
    fn capabilities(&self) -> Vec<AgentCapability>;
}
```

### 7.2 Executor 구현 예시 (Claude)

```rust
pub struct ClaudeExecutor {
    profile: ExecutorProfile,
    command_builder: CommandBuilder,
}

#[async_trait]
impl Executor for ClaudeExecutor {
    async fn execute_initial_request(
        &self,
        request: CodingAgentInitialRequest,
    ) -> Result<ExecutorResult> {
        // 1. MCP 설정 파일 생성
        let mcp_config_path = generate_mcp_config(&self.profile)?;

        // 2. 커맨드 빌드
        let mut cmd = self.command_builder
            .base_command("npx")
            .arg("-y")
            .arg("@anthropic-ai/claude-code@latest")
            .arg("--mcp-config")
            .arg(&mcp_config_path)
            .arg("--prompt")
            .arg(&request.prompt)
            .cwd(&request.worktree_path)
            .build()?;

        // 3. 프로세스 생성
        let mut child = CommandGroup::new(cmd)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        // 4. 출력 캡처
        let process_id = request.process_id;
        tokio::spawn(async move {
            capture_executor_output(child, process_id).await
        });

        Ok(ExecutorResult::Success)
    }

    async fn execute_follow_up(
        &self,
        request: CodingAgentFollowUpRequest,
    ) -> Result<ExecutorResult> {
        // Follow-up 로직 유사
        // ...
    }

    fn executor_type(&self) -> String {
        "CLAUDE_CODE".to_string()
    }

    fn capabilities(&self) -> Vec<AgentCapability> {
        vec![
            AgentCapability::SessionFork,
            AgentCapability::SetupHelper,
            AgentCapability::FollowUp,
        ]
    }
}
```

### 7.3 ExecutorAction Enum

```rust
#[enum_dispatch(ExecutorAction)]
pub trait Action {
    fn executor_type(&self) -> String;
    fn run_reason(&self) -> String;
    fn build_command(&self, worktree_path: &Path) -> Result<Command>;
}

#[enum_dispatch]
pub enum ExecutorAction {
    CodingAgentInitial(CodingAgentInitialAction),
    CodingAgentFollowUp(CodingAgentFollowUpAction),
    Script(ScriptAction),
}

impl ExecutorAction {
    pub async fn execute(
        &self,
        container_service: &dyn ContainerService,
        attempt: &TaskAttempt,
    ) -> Result<ExecutionProcess> {
        container_service.start_process(attempt, self.clone()).await
    }
}
```

### 7.4 MCP 설정 생성

```rust
pub fn generate_mcp_config(profile: &ExecutorProfile) -> Result<PathBuf> {
    let config_dir = dirs::config_dir()
        .ok_or(anyhow!("Config directory not found"))?
        .join("anyon")
        .join("mcp-configs");

    std::fs::create_dir_all(&config_dir)?;

    let config_path = config_dir.join(format!("{}.json", profile.name));

    let config = json!({
        "mcpServers": profile.mcp_servers,
        "environment": profile.environment,
    });

    std::fs::write(&config_path, serde_json::to_string_pretty(&config)?)?;

    Ok(config_path)
}
```

---

## 8. MCP 서버 구현

### 8.1 MCP 서버 설정

```rust
use rmcp::{McpServer, Tool, ToolResult};

pub async fn create_mcp_server(
    deployment: Arc<LocalDeployment>,
) -> Result<McpServer> {
    let server = McpServer::new("anyon-mcp-server");

    // 도구 등록
    server.register_tool(
        "list_projects",
        list_projects_handler(deployment.clone()),
    );

    server.register_tool(
        "list_tasks",
        list_tasks_handler(deployment.clone()),
    );

    server.register_tool(
        "get_task",
        get_task_handler(deployment.clone()),
    );

    server.register_tool(
        "create_task",
        create_task_handler(deployment.clone()),
    );

    server.register_tool(
        "update_task",
        update_task_handler(deployment.clone()),
    );

    server.register_tool(
        "create_task_attempt",
        create_task_attempt_handler(deployment.clone()),
    );

    server.register_tool(
        "get_attempt_status",
        get_attempt_status_handler(deployment.clone()),
    );

    Ok(server)
}
```

### 8.2 MCP 도구 핸들러

```rust
fn list_projects_handler(
    deployment: Arc<LocalDeployment>,
) -> impl Fn(serde_json::Value) -> ToolResult + Send + Sync {
    move |_args| {
        let deployment = deployment.clone();
        Box::pin(async move {
            let projects = Project::find_all(deployment.db_service().pool())
                .await
                .map_err(|e| e.to_string())?;

            Ok(serde_json::to_value(projects).unwrap())
        })
    }
}

fn create_task_handler(
    deployment: Arc<LocalDeployment>,
) -> impl Fn(serde_json::Value) -> ToolResult + Send + Sync {
    move |args| {
        let deployment = deployment.clone();
        Box::pin(async move {
            let data: CreateTask = serde_json::from_value(args)
                .map_err(|e| e.to_string())?;

            let task = Task::create(deployment.db_service().pool(), data)
                .await
                .map_err(|e| e.to_string())?;

            Ok(serde_json::to_value(task).unwrap())
        })
    }
}

fn create_task_attempt_handler(
    deployment: Arc<LocalDeployment>,
) -> impl Fn(serde_json::Value) -> ToolResult + Send + Sync {
    move |args| {
        let deployment = deployment.clone();
        Box::pin(async move {
            let data: CreateTaskAttempt = serde_json::from_value(args)
                .map_err(|e| e.to_string())?;

            // TaskAttempt 생성
            let attempt = TaskAttempt::create(deployment.db_service().pool(), data)
                .await
                .map_err(|e| e.to_string())?;

            // 워크트리 생성 및 실행 시작
            deployment.container_service()
                .start_process(&attempt, ExecutorAction::CodingAgentInitial(data.into()))
                .await
                .map_err(|e| e.to_string())?;

            Ok(serde_json::to_value(attempt).unwrap())
        })
    }
}
```

---

## 9. 실시간 통신

### 9.1 EventService

```rust
pub struct EventService {
    msg_store: Arc<MsgStore>,
    db_service: Arc<DBService>,
}

impl EventService {
    pub fn subscribe_entity_updates(
        &self,
        entity_type: &str,
        entity_id: Uuid,
    ) -> impl Stream<Item = serde_json::Value> {
        let msg_store = self.msg_store.clone();
        let key = format!("{}:{}", entity_type, entity_id);

        stream! {
            let mut receiver = msg_store.subscribe(&key);

            while let Ok(patch) = receiver.recv().await {
                yield patch;
            }
        }
    }

    pub fn create_hook(
        msg_store: Arc<MsgStore>,
        db_service: Arc<DBService>,
    ) -> impl Fn(&mut Connection) -> Result<(), BoxDynError> + Send + Sync + 'static {
        move |conn: &mut Connection| {
            conn.preupdate_hook(Some(move |action, db, table, old_rowid, new_rowid| {
                // Preupdate 훅 로직
                // ...
            }));

            Ok(())
        }
    }
}
```

### 9.2 MsgStore

```rust
pub struct MsgStore {
    channels: DashMap<String, Sender<serde_json::Value>>,
}

impl MsgStore {
    pub fn new() -> Self {
        Self {
            channels: DashMap::new(),
        }
    }

    pub fn subscribe(&self, key: &str) -> Receiver<serde_json::Value> {
        let (sender, receiver) = channel(100);
        self.channels.insert(key.to_string(), sender);
        receiver
    }

    pub fn push(&self, key: &str, value: serde_json::Value) {
        if let Some(sender) = self.channels.get(key) {
            let _ = sender.try_send(value);
        }
    }
}
```

---

## 10. Git 통합

### 10.1 Git 작업

**브랜치 관리:**
```rust
pub async fn create_branch(
    repo_path: &Path,
    branch_name: &str,
    base_branch: &str,
) -> Result<()> {
    let repo = Repository::open(repo_path)?;
    let base_commit = repo.find_branch(base_branch, BranchType::Local)?
        .get()
        .peel_to_commit()?;

    repo.branch(branch_name, &base_commit, false)?;

    Ok(())
}

pub async fn delete_branch(
    repo_path: &Path,
    branch_name: &str,
) -> Result<()> {
    let repo = Repository::open(repo_path)?;
    let mut branch = repo.find_branch(branch_name, BranchType::Local)?;
    branch.delete()?;

    Ok(())
}
```

**Diff 생성:**
```rust
pub async fn get_diff_between_branches(
    repo_path: &Path,
    base_branch: &str,
    compare_branch: &str,
) -> Result<Vec<Diff>> {
    let repo = Repository::open(repo_path)?;

    let base_tree = get_branch_tree(&repo, base_branch)?;
    let compare_tree = get_branch_tree(&repo, compare_branch)?;

    let diff = repo.diff_tree_to_tree(
        Some(&base_tree),
        Some(&compare_tree),
        None,
    )?;

    convert_git_diff(diff)
}

fn convert_git_diff(diff: git2::Diff) -> Result<Vec<Diff>> {
    let mut diffs = Vec::new();

    diff.foreach(
        &mut |delta, _| {
            diffs.push(Diff {
                change: convert_delta_status(delta.status()),
                old_path: delta.old_file().path().map(|p| p.to_string_lossy().to_string()),
                new_path: delta.new_file().path().map(|p| p.to_string_lossy().to_string()),
                old_content: None, // 나중에 채워짐
                new_content: None,
                additions: None,
                deletions: None,
                content_omitted: false,
            });
            true
        },
        None,
        None,
        None,
    )?;

    Ok(diffs)
}
```

---

## 11. 타입 시스템

### 11.1 ts-rs 통합

```rust
#[derive(Debug, Clone, Serialize, Deserialize, TS)]
#[ts(export, export_to = "../shared/types.ts")]
pub struct Task {
    pub id: Uuid,
    pub project_id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub status: TaskStatus,
    pub parent_task_attempt: Option<Uuid>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, TS)]
#[ts(export, export_to = "../shared/types.ts")]
#[ts(rename_all = "lowercase")]
pub enum TaskStatus {
    Todo,
    InProgress,
    InReview,
    Done,
    Cancelled,
}
```

### 11.2 타입 생성

```bash
# TypeScript 타입 생성
cargo run --bin generate_types
```

**generate_types.rs:**
```rust
fn main() {
    // 모든 TS 파생 타입 내보내기
    Task::export().unwrap();
    TaskStatus::export().unwrap();
    Project::export().unwrap();
    // ...
}
```

---

## 12. 비동기 아키텍쳐

### 12.1 Tokio 런타임 사용

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // 비동기 메인 함수
    // ...
}
```

### 12.2 비동기 패턴

**동시 작업:**
```rust
let (result1, result2) = tokio::join!(
    fetch_data_1(),
    fetch_data_2(),
);
```

**백그라운드 작업:**
```rust
tokio::spawn(async move {
    // 백그라운드 작업
    cleanup_old_data().await;
});
```

---

## 13. 에러 처리

### 13.1 에러 타입 계층

```rust
#[derive(Error, Debug)]
pub enum GitServiceError {
    #[error("Repository not found: {0}")]
    RepoNotFound(String),

    #[error("Git operation failed: {0}")]
    GitError(#[from] git2::Error),

    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}
```

---

## 14. 설정 및 환경

### 14.1 환경 변수

```bash
BACKEND_PORT=8000
FRONTEND_PORT=3000
HOST=0.0.0.0
DISABLE_WORKTREE_ORPHAN_CLEANUP=1
```

---

## 15. 고급 주제

### 15.1 파일 검색 최적화

**FST 기반 인덱싱:**
- 시간 복잡도: O(log n)
- 퍼지 매칭 지원
- 캐싱으로 빠른 검색

---

## 요약

Anyon 백엔드는 다음을 갖춘 정교한 Rust 애플리케이션입니다:

1. **타입 안정성**: 컴파일 타임 쿼리 검증
2. **실시간 업데이트**: SQLite preupdate 훅
3. **모듈식 아키텍쳐**: 7개 상호연결 crate
4. **AI 통합**: 9개 에이전트 지원
5. **Git 격리**: 워크트리 관리
6. **MCP 프로토콜**: 표준화된 AI 통신
7. **비동기 우선**: Tokio 런타임
8. **성능**: FST 인덱싱, 캐싱, 스트리밍

**핵심 아키텍쳐 강점:** 명확한 관심사 분리, 트레이트 기반 추상화, 타입 안정성이 유지보수 가능하고 확장 가능한 시스템을 만듭니다.
